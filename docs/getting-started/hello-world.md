---
layout: default
title: Hello World
parent: Getting Started
nav_order: 2
---

# Hello World

Let's walk through a complete OPAL program to understand the syntax.

---

## The Program

Here's the simplest OPAL program:

```
§M{m001:Hello}
§F{f001:Main:pub}
  §O{void}
  §E{cw}
  §P "Hello from OPAL!"
§/F{f001}
§/M{m001}
```

---

## Line by Line

### Module Declaration

```
§M{m001:Hello}
```

| Part | Meaning |
|:-----|:--------|
| `§M` | Module tag (like C# `namespace`) |
| `m001` | Unique module ID |
| `Hello` | Module name |

### Function Declaration

```
§F{f001:Main:pub}
```

| Part | Meaning |
|:-----|:--------|
| `§F` | Function tag |
| `f001` | Unique function ID |
| `Main` | Function name (entry point) |
| `pub` | Visibility (public) |

### Output Type

```
  §O{void}
```

| Part | Meaning |
|:-----|:--------|
| `§O` | Output/return type tag |
| `void` | Returns nothing |

### Effects Declaration

```
  §E{cw}
```

| Part | Meaning |
|:-----|:--------|
| `§E` | Effects tag |
| `cw` | Console write |

This declares that the function writes to console. If you forget this, the compiler will warn you.

### Print Statement

```
  §P "Hello from OPAL!"
```

| Part | Meaning |
|:-----|:--------|
| `§P` | Print statement (alias for `Console.WriteLine`) |
| `"Hello..."` | String literal to print |

### Closing Tags

```
§/F{f001}
§/M{m001}
```

Every `§F` must have a matching `§/F` with the same ID. Same for modules.

---

## Compile and Run

```bash
# Compile
dotnet run --project src/Opal.Compiler -- \
  --input samples/HelloWorld/hello.opal \
  --output samples/HelloWorld/hello.g.cs

# Run
dotnet run --project samples/HelloWorld
```

Output:
```
Hello from OPAL!
```

---

## Generated C#

The compiler produces:

```csharp
// <auto-generated>
// This file was generated by the OPAL compiler.
// </auto-generated>

namespace Hello
{
    public static class Program
    {
        public static void Main()
        {
            System.Console.WriteLine("Hello from OPAL!");
        }
    }
}
```

---

## Adding Complexity

### With Input Parameters

```
§M{m001:Greeter}
§F{f001:Greet:pub}
  §I{str:name}
  §O{void}
  §E{cw}
  §P name
§/F{f001}
§/M{m001}
```

### With Return Value

```
§M{m001:Math}
§F{f001:Add:pub}
  §I{i32:a}
  §I{i32:b}
  §O{i32}
  §R (+ a b)
§/F{f001}
§/M{m001}
```

### With Contracts

```
§M{m001:SafeMath}
§F{f001:Divide:pub}
  §I{i32:a}
  §I{i32:b}
  §O{i32}
  §Q (!= b 0)           // Requires: b is not zero
  §S (>= result 0)      // Ensures: result is non-negative (for positive inputs)
  §R (/ a b)
§/F{f001}
§/M{m001}
```

---

## Key Concepts

| Concept | OPAL | C# Equivalent |
|:--------|:-----|:--------------|
| Module | `§M{id:Name}` | `namespace Name` |
| Function | `§F{id:Name:vis}` | `public static void Name()` |
| Input | `§I{type:name}` | Parameter |
| Output | `§O{type}` | Return type |
| Effects | `§E{codes}` | (No equivalent - implicit) |
| Print | `§P expr` | `Console.WriteLine(expr)` |
| Return | `§R expr` | `return expr` |
| Close | `§/X{id}` | `}` |

---

## Next Steps

- [Claude Integration](/opal/getting-started/claude-integration/) - Use OPAL with AI agents
- [Syntax Reference](/opal/syntax-reference/) - Complete language reference

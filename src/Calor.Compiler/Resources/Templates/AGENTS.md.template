<!-- BEGIN CalorC SECTION - DO NOT EDIT -->
## Calor-First Project

This is an **Calor-first project**. All new code MUST be written in Calor. Existing C# files should be converted to Calor before modification.

### MANDATORY Rules for AI Agents

**Rule 0: Load syntax reference before writing Calor**
- Before writing ANY `.calr` code, ALWAYS invoke the `$calor` skill first
- This loads the authoritative syntax reference into context
- Applies to: new files, conversions, and edits to existing .calr files

**Rule 1: Never create new `.cs` files**
- All new code MUST be written in Calor (`.calr` files)
- Calor files compile automatically during `dotnet build`
- Use the `$calor` skill for syntax assistance

**Rule 2: Convert C# to Calor before modifying**
- Before modifying ANY `.cs` file, convert it to Calor first using `$calor-convert`
- Make your changes in the new `.calr` file, not the original `.cs` file
- Delete the original `.cs` file after successful conversion
- Run `calor analyze <file.cs>` to understand the file's complexity before conversion

**Rule 3: Never edit generated files**
- Files ending in `.g.cs` are auto-generated from Calor - do not edit them
- If you need to change generated output, edit the source `.calr` file instead

**Rule 4: Validate syntax after writing**
- After writing or editing ANY `.calr` file, run `calor diagnose <file.calr>`
- Fix any reported errors before proceeding
- This catches ALL syntax mistakes at once (build only shows first error)

### Workflow for Any Code Change

1. **Always first** → Invoke `$calor` skill to load syntax reference
2. **New feature/file?** → Create `.calr` file
3. **Modify existing `.calr` file?** → Edit directly
4. **Modify existing `.cs` file?** → Convert to `.calr` first
5. **After any .calr change** → Run `calor diagnose` to validate

### File Types
- `.calr` - Calor source files (**use this for all code**)
- `.g.cs` - Generated C# files (never edit)
- `.cs` - Legacy C# files (**convert to Calor before modifying**)

#### Available Skills
- `$calor` - Write Calor code with v2+ syntax
- `$calor-convert` - Convert C# to Calor

#### Key Commands
```bash
calor analyze <path>                 # Score files for Calor migration potential
calor diagnose <file.calr>           # Validate syntax - shows ALL errors at once
calor --input file.calr -o file.g.cs # Compile Calor to C#
calor convert file.cs                # Convert C# to Calor
calor convert file.calr              # Convert Calor to C#
```

#### Calor v2+ Syntax Reference

| Structure | Syntax |
|-----------|--------|
| Module | `§M{id:Name}` ... `§/M{id}` |
| Function | `§F{id:Name:vis}` ... `§/F{id}` |
| Async Func | `§AF{id:Name:vis}` ... `§/AF{id}` |
| Input | `§I{type:name}` |
| Output | `§O{type}` |
| Effects | `§E{cw,db,net}` |
| Loop | `§L{id:var:from:to:step}` ... `§/L{id}` |
| Conditional | `§IF{id} condition → action` |
| Try/Catch | `§TR{id}` ... `§CA{Type:var}` ... `§FI` ... `§/TR{id}` |

**Expressions (Lisp-style):** `(+ a b)`, `(== x 0)`, `(% i 15)`

**Statements:**
- Print: `§P "message"` or `§P variable`
- Bind: `§B{name} expr`
- Return: `§R expr`
- Await: `§AWAIT expr` or `§AWAIT{false} expr`

**Contracts:** `§Q (> x 0)` (precondition), `§S (>= result 0)` (postcondition)

**Collections:**
- List: `§LIST{name:type}` ... `§/LIST{name}`, `§PUSH{name} value`
- Dict: `§DICT{name:key:val}` ... `§KV key val` ... `§/DICT{name}`
- HashSet: `§HSET{name:type}` ... `§/HSET{name}`

#### Type Mappings
| C# | Calor |
|---|---|
| `int` | `i32` |
| `long` | `i64` |
| `string` | `str` |
| `bool` | `bool` |
| `void` | `void` |
| `Task<T>` | (use `§AF`/`§AMT`) |

#### Enforcement Note
Calor-first enforcement in Codex is **guidance-based only**. Unlike Claude Code which uses hooks to block `.cs` creation, Codex relies on following these instructions. Please review file extensions after generation.

*Generated by calor v{{VERSION}}*
<!-- END CalorC SECTION -->

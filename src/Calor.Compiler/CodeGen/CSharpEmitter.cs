using System.Text;
using Calor.Compiler.Ast;
using Calor.Compiler.Migration;
using Calor.Compiler.Verification;
using Calor.Compiler.Verification.Z3;

// Import ContractMode from Program.cs
using ContractMode = Calor.Compiler.ContractMode;

namespace Calor.Compiler.CodeGen;

/// <summary>
/// Contract enforcement mode for code generation.
/// </summary>
public enum EmitContractMode
{
    /// <summary>
    /// No contract checks emitted.
    /// </summary>
    Off,

    /// <summary>
    /// Full contract checks with detailed messages.
    /// </summary>
    Debug,

    /// <summary>
    /// Lean contract checks with minimal messages.
    /// </summary>
    Release
}

/// <summary>
/// Emits C# source code from an Calor AST.
/// </summary>
public sealed class CSharpEmitter : IAstVisitor<string>
{
    private readonly StringBuilder _builder = new();
    private int _indentLevel;
    private string? _currentClassName;
    private string? _currentFunctionId;
    private string? _currentFilePath;
    private readonly EmitContractMode _contractMode;
    private readonly ModuleVerificationResult? _verificationResults;
    private readonly ModuleInheritanceResult? _inheritanceResult;

    // Track current indices for contract emission
    private int _currentPreconditionIndex;
    private int _currentPostconditionIndex;

    // Track declared variables in current function scope for reassignment detection
    private readonly HashSet<string> _declaredVariablesInCurrentScope = new(StringComparer.Ordinal);

    public CSharpEmitter() : this(EmitContractMode.Debug)
    {
    }

    public CSharpEmitter(ContractMode contractMode) : this(contractMode, null, null)
    {
    }

    public CSharpEmitter(ContractMode contractMode, ModuleVerificationResult? verificationResults)
        : this(contractMode, verificationResults, null)
    {
    }

    public CSharpEmitter(ContractMode contractMode, ModuleVerificationResult? verificationResults, ModuleInheritanceResult? inheritanceResult)
    {
        _contractMode = contractMode switch
        {
            ContractMode.Off => EmitContractMode.Off,
            ContractMode.Release => EmitContractMode.Release,
            _ => EmitContractMode.Debug
        };
        _verificationResults = verificationResults;
        _inheritanceResult = inheritanceResult;
    }

    public CSharpEmitter(EmitContractMode contractMode)
    {
        _contractMode = contractMode;
    }

    public string Emit(ModuleNode module, string? filePath = null)
    {
        _builder.Clear();
        _indentLevel = 0;
        _currentFilePath = filePath;

        var result = Visit(module);
        return result;
    }

    public string Emit(ModuleNode module)
    {
        return Emit(module, null);
    }

    private void AppendLine(string line = "")
    {
        if (string.IsNullOrEmpty(line))
        {
            _builder.AppendLine();
        }
        else
        {
            _builder.Append(new string(' ', _indentLevel * 4));
            _builder.AppendLine(line);
        }
    }

    private void Indent() => _indentLevel++;
    private void Dedent() => _indentLevel--;

    public string Visit(ModuleNode node)
    {
        AppendLine("// <auto-generated>");
        AppendLine("// This code was generated by the Calor compiler.");
        AppendLine("// Do not modify this file directly.");
        AppendLine("// </auto-generated>");
        AppendLine();
        AppendLine("#nullable enable");
        AppendLine();

        // Always include System, Calor.Runtime, and commonly-needed namespaces
        var emittedUsings = new HashSet<string>(StringComparer.Ordinal)
            { "System", "Calor.Runtime", "System.Collections.Generic", "System.Linq" };
        AppendLine("using System;");
        AppendLine("using Calor.Runtime;");
        AppendLine("using System.Collections.Generic;");
        AppendLine("using System.Linq;");

        // Emit user-defined using directives
        foreach (var usingDirective in node.Usings)
        {
            var usingCode = Visit(usingDirective);
            if (!string.IsNullOrEmpty(usingCode))
            {
                // Track to avoid duplicates
                if (!emittedUsings.Contains(usingDirective.Namespace))
                {
                    AppendLine(usingCode);
                    emittedUsings.Add(usingDirective.Namespace);
                }
            }
        }
        AppendLine();

        var isGlobalNamespace = node.Name == "_global" || string.IsNullOrEmpty(node.Name);
        var namespaceName = isGlobalNamespace ? "" : SanitizeNamespace(node.Name);

        // Emit module-level extended metadata as file-level comments
        if (node.Context != null)
        {
            var contextComment = Visit(node.Context);
            foreach (var line in contextComment.Split('\n'))
            {
                AppendLine(line);
            }
            AppendLine();
        }
        foreach (var decision in node.Decisions)
        {
            var decisionComment = Visit(decision);
            foreach (var line in decisionComment.Split('\n'))
            {
                AppendLine(line);
            }
            AppendLine();
        }

        if (!isGlobalNamespace)
        {
            AppendLine($"namespace {namespaceName}");
            AppendLine("{");
            Indent();
        }

        // Emit module-level issues as comments
        foreach (var issue in node.Issues)
        {
            AppendLine(Visit(issue));
        }
        // Emit module-level assumptions
        foreach (var assume in node.Assumptions)
        {
            AppendLine(Visit(assume));
        }
        // Emit module-level invariants as comments
        foreach (var invariant in node.Invariants)
        {
            var invCode = Visit(invariant);
            AppendLine($"// INVARIANT: {invCode}");
        }
        if (node.Issues.Count > 0 || node.Assumptions.Count > 0 || node.Invariants.Count > 0)
        {
            AppendLine();
        }

        // Emit interfaces
        foreach (var iface in node.Interfaces)
        {
            Visit(iface);
            AppendLine();
        }

        // Emit enums
        foreach (var enumDef in node.Enums)
        {
            Visit(enumDef);
            AppendLine();
        }

        // Emit enum extensions
        foreach (var enumExt in node.EnumExtensions)
        {
            Visit(enumExt);
            AppendLine();
        }

        // Emit delegates
        foreach (var del in node.Delegates)
        {
            Visit(del);
            AppendLine();
        }

        // Emit classes
        foreach (var cls in node.Classes)
        {
            Visit(cls);
            AppendLine();
        }

        // Emit module-level functions in a static class
        if (node.Functions.Count > 0)
        {
            var moduleClassName = isGlobalNamespace
                ? "GlobalModule"
                : SanitizeIdentifier(node.Name.Contains('.')
                    ? node.Name.Split('.').Last()
                    : node.Name) + "Module";
            AppendLine($"public static class {moduleClassName}");
            AppendLine("{");
            Indent();

            foreach (var function in node.Functions)
            {
                Visit(function);
                AppendLine();
            }

            Dedent();
            AppendLine("}");
        }

        if (!isGlobalNamespace)
        {
            Dedent();
            AppendLine("}");
        }

        return _builder.ToString();
    }

    public string Visit(UsingDirectiveNode node)
    {
        if (node.IsStatic)
        {
            return $"using static {node.Namespace};";
        }
        else if (node.Alias != null)
        {
            return $"using {node.Alias} = {node.Namespace};";
        }
        else
        {
            return $"using {node.Namespace};";
        }
    }

    public string Visit(FunctionNode node)
    {
        // Track current function ID for contract emission
        _currentFunctionId = node.Id;

        // Reset contract indices for this function
        _currentPreconditionIndex = 0;
        _currentPostconditionIndex = 0;

        // Clear declared variables tracking for new function scope
        _declaredVariablesInCurrentScope.Clear();

        // Emit extended metadata as documentation comments
        foreach (var issue in node.Issues)
        {
            AppendLine(Visit(issue));
        }
        if (node.Uses != null)
        {
            AppendLine(Visit(node.Uses));
        }
        if (node.UsedBy != null)
        {
            AppendLine(Visit(node.UsedBy));
        }
        foreach (var assume in node.Assumptions)
        {
            AppendLine(Visit(assume));
        }
        if (node.Complexity != null)
        {
            AppendLine(Visit(node.Complexity));
        }
        if (node.Since != null)
        {
            AppendLine(Visit(node.Since));
        }
        foreach (var breaking in node.BreakingChanges)
        {
            AppendLine(Visit(breaking));
        }
        foreach (var prop in node.Properties)
        {
            AppendLine(Visit(prop));
        }
        if (node.Lock != null)
        {
            AppendLine(Visit(node.Lock));
        }
        if (node.Author != null)
        {
            AppendLine(Visit(node.Author));
        }
        if (node.TaskRef != null)
        {
            AppendLine(Visit(node.TaskRef));
        }

        // Emit [Obsolete] attribute if deprecated
        if (node.Deprecated != null)
        {
            AppendLine(Visit(node.Deprecated));
        }

        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "private"
        };

        var returnType = node.Output?.TypeName ?? "void";
        var mappedReturnType = MapTypeName(returnType);
        // Wrap in Task if async
        if (node.IsAsync)
        {
            mappedReturnType = WrapInTask(mappedReturnType);
        }
        var hasReturnValue = returnType.ToUpperInvariant() != "VOID";

        var parameters = string.Join(", ", node.Parameters.Select(p =>
            $"{MapTypeName(p.TypeName)} {SanitizeIdentifier(p.Name)}"));

        var methodName = SanitizeIdentifier(node.Name);

        // Build type parameters if present
        var typeParams = "";
        var whereClause = "";
        if (node.TypeParameters.Count > 0)
        {
            typeParams = "<" + string.Join(", ", node.TypeParameters.Select(tp => tp.Name)) + ">";

            // Build where clauses
            var whereClauses = new List<string>();
            foreach (var tp in node.TypeParameters)
            {
                if (tp.Constraints.Count > 0)
                {
                    var constraints = string.Join(", ", tp.Constraints.Select(c => EmitConstraint(c)));
                    whereClauses.Add($"where {tp.Name} : {constraints}");
                }
            }
            if (whereClauses.Count > 0)
            {
                whereClause = " " + string.Join(" ", whereClauses);
            }
        }

        // Check if this is the entry point
        var isMain = node.Name.Equals("Main", StringComparison.OrdinalIgnoreCase);
        var staticKeyword = "static "; // All module functions are static
        var asyncKeyword = node.IsAsync ? "async " : "";

        AppendLine($"{visibility} {staticKeyword}{asyncKeyword}{mappedReturnType} {methodName}{typeParams}({parameters}){whereClause}");
        AppendLine("{");
        Indent();

        // Emit inline examples as Debug.Assert
        foreach (var example in node.Examples)
        {
            AppendLine(Visit(example));
        }

        // Emit preconditions (REQUIRES)
        foreach (var requires in node.Preconditions)
        {
            var check = Visit(requires);
            AppendLine(check);
        }

        // If we have postconditions and a return value, we need special handling
        if (node.Postconditions.Count > 0 && hasReturnValue)
        {
            AppendLine($"{mappedReturnType} __result__ = default;");
            AppendLine();

            // Emit body statements, transforming return statements
            foreach (var statement in node.Body)
            {
                if (statement is ReturnStatementNode returnStmt && returnStmt.Expression != null)
                {
                    var expr = returnStmt.Expression.Accept(this);
                    AppendLine($"__result__ = {expr};");
                }
                else
                {
                    var stmtCode = statement.Accept(this);
                    AppendLine(stmtCode);
                }
            }

            AppendLine();
            // Emit postconditions (ENSURES)
            foreach (var ensures in node.Postconditions)
            {
                // Replace 'result' references with '__result__'
                var check = Visit(ensures).Replace("result", "__result__");
                AppendLine(check);
            }

            AppendLine("return __result__;");
        }
        else
        {
            // No postconditions or void return - emit body normally
            foreach (var statement in node.Body)
            {
                var stmtCode = statement.Accept(this);
                AppendLine(stmtCode);
            }

            // Emit postconditions for void functions (they can't reference 'result')
            foreach (var ensures in node.Postconditions)
            {
                var check = Visit(ensures);
                AppendLine(check);
            }
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(ParameterNode node)
    {
        return $"{MapTypeName(node.TypeName)} {SanitizeIdentifier(node.Name)}";
    }

    public string Visit(CallStatementNode node)
    {
        var target = node.Target;
        var args = string.Join(", ", node.Arguments.Select(a => a.Accept(this)));

        return $"{target}({args});";
    }

    public string Visit(ReturnStatementNode node)
    {
        if (node.Expression == null)
        {
            return "return;";
        }

        var expr = node.Expression.Accept(this);
        return $"return {expr};";
    }

    public string Visit(IntLiteralNode node)
    {
        return node.Value.ToString();
    }

    public string Visit(StringLiteralNode node)
    {
        // Check if this is an interpolated string (contains ${identifier})
        // Only match Calor interpolation syntax: ${identifier}, not format placeholders ${0}
        // Calor interpolation uses identifiers (letters, underscores), not numbers
        var interpolationRegex = new System.Text.RegularExpressions.Regex(@"\$\{([a-zA-Z_][a-zA-Z0-9_]*(?:\??\.[a-zA-Z_][a-zA-Z0-9_]*)*)\}");
        if (interpolationRegex.IsMatch(node.Value))
        {
            // Convert Calor interpolation ${expr} to C# interpolation {expr}
            var converted = interpolationRegex.Replace(node.Value, "{$1}");

            // Escape for C# string literal (but not the interpolation braces)
            var escaped = converted
                .Replace("\\", "\\\\")
                .Replace("\"", "\\\"")
                .Replace("\n", "\\n")
                .Replace("\r", "\\r")
                .Replace("\t", "\\t");

            return $"$\"{escaped}\"";
        }

        // Escape the string for C#
        var escapedValue = node.Value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");

        return $"\"{escapedValue}\"";
    }

    public string Visit(BoolLiteralNode node)
    {
        return node.Value ? "true" : "false";
    }

    public string Visit(ConditionalExpressionNode node)
    {
        var condition = node.Condition.Accept(this);
        var whenTrue = node.WhenTrue.Accept(this);
        var whenFalse = node.WhenFalse.Accept(this);
        return $"({condition} ? {whenTrue} : {whenFalse})";
    }

    public string Visit(FloatLiteralNode node)
    {
        var str = node.Value.ToString(System.Globalization.CultureInfo.InvariantCulture);
        return node.IsDecimal ? str + "m" : str;
    }

    public string Visit(ReferenceNode node)
    {
        // Handle 'is' pattern expressions like "other is UnitSystem otherUnitSystem"
        // These should be emitted as-is without sanitization
        if (node.Name.Contains(" is "))
        {
            return node.Name;
        }

        // Handle C# keywords that are used as literals (not identifiers)
        if (node.Name is "null" or "true" or "false")
        {
            return node.Name;
        }

        // Handle member access like "args.Length" - preserve the dot notation
        if (node.Name.Contains('.'))
        {
            var parts = node.Name.Split('.');
            var sanitizedParts = parts.Select(SanitizeIdentifier);
            return string.Join(".", sanitizedParts);
        }
        return SanitizeIdentifier(node.Name);
    }

    // Phase 2: Control Flow

    public string Visit(ForStatementNode node)
    {
        var varName = SanitizeIdentifier(node.VariableName);
        var from = node.From.Accept(this);
        var to = node.To.Accept(this);
        var step = node.Step?.Accept(this) ?? "1";

        // Determine loop direction based on step (simple heuristic)
        var isPositiveStep = !step.StartsWith("-");
        var comparison = isPositiveStep ? "<=" : ">=";
        var increment = step == "1" ? $"{varName}++" : $"{varName} += {step}";

        AppendLine($"for (var {varName} = {from}; {varName} {comparison} {to}; {increment})");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            var stmtCode = stmt.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(WhileStatementNode node)
    {
        var condition = node.Condition.Accept(this);

        AppendLine($"while ({condition})");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            var stmtCode = stmt.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(DoWhileStatementNode node)
    {
        var condition = node.Condition.Accept(this);

        AppendLine("do");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            var stmtCode = stmt.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine($"}} while ({condition});");

        return "";
    }

    public string Visit(IfStatementNode node)
    {
        var condition = node.Condition.Accept(this);

        AppendLine($"if ({condition})");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.ThenBody)
        {
            var stmtCode = stmt.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine("}");

        // Emit ELSEIF clauses
        foreach (var elseIf in node.ElseIfClauses)
        {
            var elseIfCondition = elseIf.Condition.Accept(this);
            AppendLine($"else if ({elseIfCondition})");
            AppendLine("{");
            Indent();

            foreach (var stmt in elseIf.Body)
            {
                var stmtCode = stmt.Accept(this);
                AppendLine(stmtCode);
            }

            Dedent();
            AppendLine("}");
        }

        // Emit ELSE clause
        if (node.ElseBody != null)
        {
            AppendLine("else");
            AppendLine("{");
            Indent();

            foreach (var stmt in node.ElseBody)
            {
                var stmtCode = stmt.Accept(this);
                AppendLine(stmtCode);
            }

            Dedent();
            AppendLine("}");
        }

        return "";
    }

    public string Visit(BindStatementNode node)
    {
        var varName = SanitizeIdentifier(node.Name);
        var typeName = node.TypeName != null ? MapTypeName(node.TypeName) : "var";

        // Only emit assignment (not declaration) if:
        // 1. The variable is marked as mutable (Â§B{~name:type})
        // 2. AND it was already declared in this scope
        // This preserves Calor's shadowing semantics (S5-S6): immutable binds in inner
        // scopes create new shadowing variables, while mutable binds reassign.
        if (node.IsMutable && _declaredVariablesInCurrentScope.Contains(varName))
        {
            // Mutable rebind - emit assignment only
            if (node.Initializer != null)
            {
                var initExpr = node.Initializer.Accept(this);
                return $"{varName} = {initExpr};";
            }
            return "";
        }

        _declaredVariablesInCurrentScope.Add(varName);

        if (node.Initializer != null)
        {
            var initExpr = node.Initializer.Accept(this);
            return $"{typeName} {varName} = {initExpr};";
        }

        // No initializer - need explicit type
        if (node.TypeName == null)
        {
            typeName = "int"; // Default to int
        }
        return $"{typeName} {varName} = default;";
    }

    public string Visit(BinaryOperationNode node)
    {
        var left = node.Left.Accept(this);
        var right = node.Right.Accept(this);

        // Special handling for Power operator (use Math.Pow)
        if (node.Operator == BinaryOperator.Power)
        {
            return $"Math.Pow({left}, {right})";
        }

        var op = node.Operator.ToCSharpOperator();
        return $"({left} {op} {right})";
    }

    public string Visit(UnaryOperationNode node)
    {
        var operand = node.Operand.Accept(this);
        var op = node.Operator.ToCSharpOperator();
        if (node.Operator is UnaryOperator.PostIncrement or UnaryOperator.PostDecrement)
            return $"({operand}{op})";
        return $"({op}{operand})";
    }

    public string Visit(PrintStatementNode node)
    {
        var expr = node.Expression.Accept(this);
        var method = node.IsWriteLine ? "Console.WriteLine" : "Console.Write";
        return $"{method}({expr});";
    }

    public string Visit(ContinueStatementNode node)
    {
        return "continue;";
    }

    public string Visit(BreakStatementNode node)
    {
        return "break;";
    }

    // Phase 3: Type System

    public string Visit(RecordDefinitionNode node)
    {
        AppendLine($"public record {SanitizeIdentifier(node.Name)}(");
        Indent();

        for (int i = 0; i < node.Fields.Count; i++)
        {
            var field = node.Fields[i];
            var typeName = MapTypeName(field.TypeName);
            var fieldName = SanitizeIdentifier(field.Name);
            var comma = i < node.Fields.Count - 1 ? "," : "";
            AppendLine($"{typeName} {fieldName}{comma}");
        }

        Dedent();
        AppendLine(");");

        return "";
    }

    public string Visit(UnionTypeDefinitionNode node)
    {
        // Generate as abstract base class with derived classes for each variant
        var typeName = SanitizeIdentifier(node.Name);

        AppendLine($"public abstract record {typeName};");
        AppendLine();

        foreach (var variant in node.Variants)
        {
            var variantName = SanitizeIdentifier(variant.Name);
            if (variant.Fields.Count == 0)
            {
                AppendLine($"public sealed record {variantName}() : {typeName};");
            }
            else
            {
                var fields = string.Join(", ", variant.Fields.Select(f =>
                    $"{MapTypeName(f.TypeName)} {SanitizeIdentifier(f.Name)}"));
                AppendLine($"public sealed record {variantName}({fields}) : {typeName};");
            }
        }

        return "";
    }

    public string Visit(EnumDefinitionNode node)
    {
        // Generate C# enum with optional underlying type
        var typeName = SanitizeIdentifier(node.Name);
        var baseType = node.UnderlyingType != null
            ? $" : {MapTypeName(node.UnderlyingType)}"
            : "";

        AppendLine($"public enum {typeName}{baseType}");
        AppendLine("{");
        Indent();

        foreach (var member in node.Members)
        {
            Visit(member);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(EnumMemberNode node)
    {
        var memberName = SanitizeIdentifier(node.Name);
        var value = node.Value != null ? $" = {node.Value}" : "";
        AppendLine($"{memberName}{value},");
        return "";
    }

    public string Visit(EnumExtensionNode node)
    {
        // Generate a static extension class for the enum
        var enumName = SanitizeIdentifier(node.EnumName);
        var className = $"{enumName}Extensions";

        AppendLine($"public static class {className}");
        AppendLine("{");
        Indent();

        foreach (var method in node.Methods)
        {
            EmitExtensionMethod(method, enumName);
            AppendLine();
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    /// <summary>
    /// Emits an extension method for an enum.
    /// The first parameter with the enum type becomes the 'this' parameter.
    /// </summary>
    private void EmitExtensionMethod(FunctionNode method, string enumName)
    {
        // Track current function ID for contract emission
        _currentFunctionId = method.Id;
        _currentPreconditionIndex = 0;
        _currentPostconditionIndex = 0;

        // Emit extended metadata as documentation comments
        foreach (var issue in method.Issues)
        {
            AppendLine(Visit(issue));
        }
        if (method.Deprecated != null)
        {
            AppendLine(Visit(method.Deprecated));
        }

        var visibility = method.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "public"
        };

        var returnType = method.Output?.TypeName ?? "void";
        var mappedReturnType = MapTypeName(returnType);
        if (method.IsAsync)
        {
            mappedReturnType = WrapInTask(mappedReturnType);
        }
        var hasReturnValue = returnType.ToUpperInvariant() != "VOID";

        // Find the 'self' parameter (the one with the enum type) and make it the 'this' parameter
        var selfParam = method.Parameters.FirstOrDefault(p =>
            p.TypeName.Equals(enumName, StringComparison.OrdinalIgnoreCase) ||
            p.Name.Equals("self", StringComparison.OrdinalIgnoreCase));

        var parameters = new List<string>();
        var hasThisParam = false;

        foreach (var p in method.Parameters)
        {
            var paramType = MapTypeName(p.TypeName);
            var paramName = SanitizeIdentifier(p.Name);

            if (p == selfParam && !hasThisParam)
            {
                // This is the extension method 'this' parameter
                parameters.Add($"this {paramType} {paramName}");
                hasThisParam = true;
            }
            else
            {
                parameters.Add($"{paramType} {paramName}");
            }
        }

        var paramString = string.Join(", ", parameters);
        var methodName = SanitizeIdentifier(method.Name);

        // Build type parameters if present
        var typeParams = "";
        var whereClause = "";
        if (method.TypeParameters.Count > 0)
        {
            typeParams = "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">";

            var whereClauses = new List<string>();
            foreach (var tp in method.TypeParameters)
            {
                if (tp.Constraints.Count > 0)
                {
                    var constraints = string.Join(", ", tp.Constraints.Select(c => EmitConstraint(c)));
                    whereClauses.Add($"where {tp.Name} : {constraints}");
                }
            }
            if (whereClauses.Count > 0)
            {
                whereClause = " " + string.Join(" ", whereClauses);
            }
        }

        var asyncKeyword = method.IsAsync ? "async " : "";

        AppendLine($"{visibility} static {asyncKeyword}{mappedReturnType} {methodName}{typeParams}({paramString}){whereClause}");
        AppendLine("{");
        Indent();

        // Emit preconditions
        foreach (var requires in method.Preconditions)
        {
            var check = Visit(requires);
            AppendLine(check);
        }

        // If we have postconditions and a return value, we need special handling
        if (method.Postconditions.Count > 0 && hasReturnValue)
        {
            AppendLine($"{mappedReturnType} __result__ = default;");
            AppendLine();

            foreach (var statement in method.Body)
            {
                if (statement is ReturnStatementNode returnStmt && returnStmt.Expression != null)
                {
                    var expr = returnStmt.Expression.Accept(this);
                    AppendLine($"__result__ = {expr};");
                }
                else
                {
                    var stmtCode = statement.Accept(this);
                    AppendLine(stmtCode);
                }
            }

            AppendLine();
            foreach (var ensures in method.Postconditions)
            {
                var check = Visit(ensures).Replace("result", "__result__");
                AppendLine(check);
            }

            AppendLine("return __result__;");
        }
        else
        {
            foreach (var statement in method.Body)
            {
                var stmtCode = statement.Accept(this);
                AppendLine(stmtCode);
            }

            foreach (var ensures in method.Postconditions)
            {
                var check = Visit(ensures);
                AppendLine(check);
            }
        }

        Dedent();
        AppendLine("}");
    }

    public string Visit(RecordCreationNode node)
    {
        var typeName = SanitizeIdentifier(node.TypeName);
        var fields = string.Join(", ", node.Fields.Select(f => f.Value.Accept(this)));
        return $"new {typeName}({fields})";
    }

    public string Visit(FieldAccessNode node)
    {
        var target = node.Target.Accept(this);
        var fieldName = SanitizeIdentifier(node.FieldName);
        return $"{target}.{fieldName}";
    }

    public string Visit(SomeExpressionNode node)
    {
        var value = node.Value.Accept(this);
        return $"Calor.Runtime.Option.Some({value})";
    }

    public string Visit(NoneExpressionNode node)
    {
        if (node.TypeName != null)
        {
            var typeName = MapTypeName(node.TypeName);
            return $"Calor.Runtime.Option<{typeName}>.None()";
        }
        return "Calor.Runtime.Option.None<object>()";
    }

    public string Visit(OkExpressionNode node)
    {
        var value = node.Value.Accept(this);
        return $"Calor.Runtime.Result.Ok<{GetInferredTypeName(node.Value)}, string>({value})";
    }

    public string Visit(ErrExpressionNode node)
    {
        var error = node.Error.Accept(this);
        return $"Calor.Runtime.Result.Err<object, {GetInferredTypeName(node.Error)}>({error})";
    }

    public string Visit(MatchExpressionNode node)
    {
        // Generate as switch expression
        var target = node.Target.Accept(this);
        var sb = new System.Text.StringBuilder();
        sb.Append($"{target} switch {{ ");

        for (int i = 0; i < node.Cases.Count; i++)
        {
            var matchCase = node.Cases[i];
            var pattern = EmitPattern(matchCase.Pattern);

            // Emit guard clause if present
            var guard = matchCase.Guard != null ? $" when {matchCase.Guard.Accept(this)}" : "";

            // For expression match, the body should yield a value
            // Take the last statement if it's a return, otherwise default
            var body = "default";
            if (matchCase.Body.Count > 0)
            {
                var lastStmt = matchCase.Body[^1];
                if (lastStmt is ReturnStatementNode ret && ret.Expression != null)
                {
                    body = ret.Expression.Accept(this);
                }
            }
            sb.Append($"{pattern}{guard} => {body}");
            if (i < node.Cases.Count - 1) sb.Append(", ");
        }

        sb.Append(" }");
        return sb.ToString();
    }

    public string Visit(MatchStatementNode node)
    {
        var target = node.Target.Accept(this);

        AppendLine($"switch ({target})");
        AppendLine("{");
        Indent();

        foreach (var matchCase in node.Cases)
        {
            var pattern = EmitPattern(matchCase.Pattern);
            AppendLine($"case {pattern}:");
            Indent();

            foreach (var stmt in matchCase.Body)
            {
                var stmtCode = stmt.Accept(this);
                AppendLine(stmtCode);
            }

            AppendLine("break;");
            Dedent();
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    private string EmitPattern(PatternNode pattern)
    {
        return pattern switch
        {
            WildcardPatternNode => "_",
            VariablePatternNode vp => $"var {SanitizeIdentifier(vp.Name)}",
            VarPatternNode varP => $"var {SanitizeIdentifier(varP.Name)}",
            LiteralPatternNode lp => lp.Literal.Accept(this),
            RelationalPatternNode rp => Visit(rp),
            PropertyPatternNode pp => Visit(pp),
            PositionalPatternNode pos => Visit(pos),
            ConstantPatternNode cp => cp.Value.Accept(this),
            SomePatternNode sp => $"{{ IsSome: true, Value: {EmitPattern(sp.InnerPattern)} }}",
            NonePatternNode => "{ IsNone: true }",
            OkPatternNode op => $"{{ IsOk: true, Value: {EmitPattern(op.InnerPattern)} }}",
            ErrPatternNode ep => $"{{ IsErr: true, Error: {EmitPattern(ep.InnerPattern)} }}",
            ListPatternNode lp => Visit(lp),
            _ => "_"
        };
    }

    public string Visit(MatchCaseNode node)
    {
        var pattern = EmitPattern(node.Pattern);
        // For match statement context, case is emitted as part of switch
        return pattern;
    }

    public string Visit(WildcardPatternNode node) => "_";

    public string Visit(VariablePatternNode node) => $"var {SanitizeIdentifier(node.Name)}";

    public string Visit(LiteralPatternNode node) => node.Literal.Accept(this);

    public string Visit(SomePatternNode node)
        => $"{{ IsSome: true, Value: {node.InnerPattern.Accept(this)} }}";

    public string Visit(NonePatternNode node) => "{ IsNone: true }";

    public string Visit(OkPatternNode node)
        => $"{{ IsOk: true, Value: {node.InnerPattern.Accept(this)} }}";

    public string Visit(ErrPatternNode node)
        => $"{{ IsErr: true, Error: {node.InnerPattern.Accept(this)} }}";

    // Phase 4: Contracts

    public string Visit(RequiresNode node)
    {
        // Off mode: no contract checks
        if (_contractMode == EmitContractMode.Off)
        {
            _currentPreconditionIndex++;
            return ""; // No check emitted
        }

        var condition = node.Condition.Accept(this);
        var functionId = _currentFunctionId ?? "unknown";

        // Check verification status if available
        var verificationStatus = GetPreconditionVerificationStatus();
        _currentPreconditionIndex++;

        // Proven preconditions: emit comment instead of runtime check
        if (verificationStatus == ContractVerificationStatus.Proven)
        {
            return $"// PROVEN: Precondition always satisfiable: {condition}";
        }

        // Release mode: lean exception
        if (_contractMode == EmitContractMode.Release)
        {
            return $"if (!({condition})) throw new Calor.Runtime.ContractViolationException(\"{EscapeString(functionId)}\", Calor.Runtime.ContractKind.Requires);";
        }

        // Debug mode: full details
        var message = node.Message != null
            ? EscapeString(node.Message)
            : $"Precondition failed: {EscapeString(condition)}";
        var sourceFile = _currentFilePath != null ? $"\"{EscapeString(_currentFilePath)}\"" : "null";

        return $"if (!({condition})) throw new Calor.Runtime.ContractViolationException(" +
               $"\"{message}\", " +
               $"\"{EscapeString(functionId)}\", " +
               $"Calor.Runtime.ContractKind.Requires, " +
               $"startOffset: {node.Span.Start}, " +
               $"length: {node.Span.Length}, " +
               $"sourceFile: {sourceFile}, " +
               $"line: {node.Span.Line}, " +
               $"column: {node.Span.Column}, " +
               $"condition: \"{EscapeString(condition)}\");";
    }

    public string Visit(EnsuresNode node)
    {
        // Off mode: no contract checks
        if (_contractMode == EmitContractMode.Off)
        {
            _currentPostconditionIndex++;
            return ""; // No check emitted
        }

        var condition = node.Condition.Accept(this);
        var functionId = _currentFunctionId ?? "unknown";

        // Check verification status if available
        var verificationStatus = GetPostconditionVerificationStatus();
        _currentPostconditionIndex++;

        // Proven postconditions: emit comment instead of runtime check
        if (verificationStatus == ContractVerificationStatus.Proven)
        {
            return $"// PROVEN: Postcondition statically verified: {condition}";
        }

        // Release mode: lean exception
        if (_contractMode == EmitContractMode.Release)
        {
            return $"if (!({condition})) throw new Calor.Runtime.ContractViolationException(\"{EscapeString(functionId)}\", Calor.Runtime.ContractKind.Ensures);";
        }

        // Debug mode: full details
        var message = node.Message != null
            ? EscapeString(node.Message)
            : $"Postcondition failed: {EscapeString(condition)}";
        var sourceFile = _currentFilePath != null ? $"\"{EscapeString(_currentFilePath)}\"" : "null";

        return $"if (!({condition})) throw new Calor.Runtime.ContractViolationException(" +
               $"\"{message}\", " +
               $"\"{EscapeString(functionId)}\", " +
               $"Calor.Runtime.ContractKind.Ensures, " +
               $"startOffset: {node.Span.Start}, " +
               $"length: {node.Span.Length}, " +
               $"sourceFile: {sourceFile}, " +
               $"line: {node.Span.Line}, " +
               $"column: {node.Span.Column}, " +
               $"condition: \"{EscapeString(condition)}\");";
    }

    public string Visit(InvariantNode node)
    {
        // Off mode: no contract checks
        if (_contractMode == EmitContractMode.Off)
        {
            return ""; // No check emitted
        }

        var condition = node.Condition.Accept(this);
        var functionId = _currentFunctionId ?? "unknown";

        // Release mode: lean exception
        if (_contractMode == EmitContractMode.Release)
        {
            return $"if (!({condition})) throw new Calor.Runtime.ContractViolationException(\"{EscapeString(functionId)}\", Calor.Runtime.ContractKind.Invariant);";
        }

        // Debug mode: full details
        var message = node.Message != null
            ? EscapeString(node.Message)
            : $"Invariant violated: {EscapeString(condition)}";
        var sourceFile = _currentFilePath != null ? $"\"{EscapeString(_currentFilePath)}\"" : "null";

        return $"if (!({condition})) throw new Calor.Runtime.ContractViolationException(" +
               $"\"{message}\", " +
               $"\"{EscapeString(functionId)}\", " +
               $"Calor.Runtime.ContractKind.Invariant, " +
               $"startOffset: {node.Span.Start}, " +
               $"length: {node.Span.Length}, " +
               $"sourceFile: {sourceFile}, " +
               $"line: {node.Span.Line}, " +
               $"column: {node.Span.Column}, " +
               $"condition: \"{EscapeString(condition)}\");";
    }

    private static string EscapeString(string s)
    {
        return s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "\\r");
    }

    private ContractVerificationStatus? GetPreconditionVerificationStatus()
    {
        if (_verificationResults == null || _currentFunctionId == null)
            return null;

        var funcResult = _verificationResults.GetFunctionResult(_currentFunctionId);
        if (funcResult == null || _currentPreconditionIndex >= funcResult.PreconditionResults.Count)
            return null;

        return funcResult.PreconditionResults[_currentPreconditionIndex].Status;
    }

    private ContractVerificationStatus? GetPostconditionVerificationStatus()
    {
        if (_verificationResults == null || _currentFunctionId == null)
            return null;

        var funcResult = _verificationResults.GetFunctionResult(_currentFunctionId);
        if (funcResult == null || _currentPostconditionIndex >= funcResult.PostconditionResults.Count)
            return null;

        return funcResult.PostconditionResults[_currentPostconditionIndex].Status;
    }

    // Phase 6: Arrays and Collections

    public string Visit(ArrayCreationNode node)
    {
        var elementType = MapTypeName(node.ElementType);

        if (node.Size != null)
        {
            // Sized array expression: new int[10] or new int[n]
            var size = node.Size.Accept(this);
            return $"new {elementType}[{size}]";
        }
        else if (node.Initializer.Count > 0)
        {
            // Initialized array expression: new[] { 1, 2, 3 }
            var elements = string.Join(", ", node.Initializer.Select(e => e.Accept(this)));
            return $"new {elementType}[] {{ {elements} }}";
        }
        else
        {
            // Empty array expression
            return $"Array.Empty<{elementType}>()";
        }
    }

    public string Visit(ArrayAccessNode node)
    {
        var array = node.Array.Accept(this);
        var index = node.Index.Accept(this);
        return $"{array}[{index}]";
    }

    public string Visit(ArrayLengthNode node)
    {
        var array = node.Array.Accept(this);
        return $"{array}.Length";
    }

    public string Visit(ForeachStatementNode node)
    {
        var varType = MapTypeName(node.VariableType);
        var varName = SanitizeIdentifier(node.VariableName);
        var collection = node.Collection.Accept(this);

        AppendLine($"foreach ({varType} {varName} in {collection})");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            var stmtCode = stmt.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    // Phase 6 Extended: Collections (List, Dictionary, HashSet)

    public string Visit(ListCreationNode node)
    {
        var elementType = MapTypeName(node.ElementType);

        if (node.Elements.Count > 0)
        {
            var elements = string.Join(", ", node.Elements.Select(e => e.Accept(this)));
            return $"new List<{elementType}>() {{ {elements} }}";
        }
        else
        {
            return $"new List<{elementType}>()";
        }
    }

    public string Visit(DictionaryCreationNode node)
    {
        var keyType = MapTypeName(node.KeyType);
        var valueType = MapTypeName(node.ValueType);

        if (node.Entries.Count > 0)
        {
            var entries = string.Join(", ", node.Entries.Select(e =>
            {
                var key = e.Key.Accept(this);
                var value = e.Value.Accept(this);
                return $"{{ {key}, {value} }}";
            }));
            return $"new Dictionary<{keyType}, {valueType}>() {{ {entries} }}";
        }
        else
        {
            return $"new Dictionary<{keyType}, {valueType}>()";
        }
    }

    public string Visit(KeyValuePairNode node)
    {
        var key = node.Key.Accept(this);
        var value = node.Value.Accept(this);
        return $"{{ {key}, {value} }}";
    }

    public string Visit(SetCreationNode node)
    {
        var elementType = MapTypeName(node.ElementType);

        if (node.Elements.Count > 0)
        {
            var elements = string.Join(", ", node.Elements.Select(e => e.Accept(this)));
            return $"new HashSet<{elementType}>() {{ {elements} }}";
        }
        else
        {
            return $"new HashSet<{elementType}>()";
        }
    }

    public string Visit(CollectionPushNode node)
    {
        var collectionName = SanitizeIdentifier(node.CollectionName);
        var value = node.Value.Accept(this);
        return $"{collectionName}.Add({value});";
    }

    public string Visit(DictionaryPutNode node)
    {
        var dictionaryName = SanitizeIdentifier(node.DictionaryName);
        var key = node.Key.Accept(this);
        var value = node.Value.Accept(this);
        return $"{dictionaryName}[{key}] = {value};";
    }

    public string Visit(CollectionRemoveNode node)
    {
        var collectionName = SanitizeIdentifier(node.CollectionName);
        var keyOrValue = node.KeyOrValue.Accept(this);
        return $"{collectionName}.Remove({keyOrValue});";
    }

    public string Visit(CollectionSetIndexNode node)
    {
        var collectionName = SanitizeIdentifier(node.CollectionName);
        var index = node.Index.Accept(this);
        var value = node.Value.Accept(this);
        return $"{collectionName}[{index}] = {value};";
    }

    public string Visit(CollectionClearNode node)
    {
        var collectionName = SanitizeIdentifier(node.CollectionName);
        return $"{collectionName}.Clear();";
    }

    public string Visit(CollectionInsertNode node)
    {
        var collectionName = SanitizeIdentifier(node.CollectionName);
        var index = node.Index.Accept(this);
        var value = node.Value.Accept(this);
        return $"{collectionName}.Insert({index}, {value});";
    }

    public string Visit(CollectionContainsNode node)
    {
        var collectionName = SanitizeIdentifier(node.CollectionName);
        var keyOrValue = node.KeyOrValue.Accept(this);

        return node.Mode switch
        {
            ContainsMode.Key => $"{collectionName}.ContainsKey({keyOrValue})",
            ContainsMode.DictValue => $"{collectionName}.ContainsValue({keyOrValue})",
            ContainsMode.Value => $"{collectionName}.Contains({keyOrValue})",
            _ => $"{collectionName}.Contains({keyOrValue})"
        };
    }

    public string Visit(DictionaryForeachNode node)
    {
        var keyName = SanitizeIdentifier(node.KeyName);
        var valueName = SanitizeIdentifier(node.ValueName);
        var dictionary = node.Dictionary.Accept(this);

        AppendLine($"foreach (var ({keyName}, {valueName}) in {dictionary})");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            var stmtCode = stmt.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(CollectionCountNode node)
    {
        var collection = node.Collection.Accept(this);
        return $"{collection}.Count";
    }

    // Phase 7: Generics

    public string Visit(TypeParameterNode node)
    {
        // Type parameters are handled in function/method signature emission
        return node.Name;
    }

    public string Visit(TypeConstraintNode node)
    {
        return EmitConstraint(node);
    }

    public string Visit(GenericTypeNode node)
    {
        var typeName = MapTypeName(node.TypeName);
        if (node.TypeArguments.Count == 0)
        {
            return typeName;
        }

        var typeArgs = string.Join(", ", node.TypeArguments.Select(MapTypeName));
        return $"{typeName}<{typeArgs}>";
    }

    private string EmitConstraint(TypeConstraintNode constraint)
    {
        return constraint.Kind switch
        {
            TypeConstraintKind.Class => "class",
            TypeConstraintKind.Struct => "struct",
            TypeConstraintKind.New => "new()",
            TypeConstraintKind.Interface => constraint.TypeName ?? "object",
            TypeConstraintKind.BaseClass => constraint.TypeName ?? "object",
            TypeConstraintKind.TypeName => MapTypeName(constraint.TypeName ?? "object"),
            _ => "object"
        };
    }

    // Phase 8: Classes, Interfaces, Inheritance

    public string Visit(InterfaceDefinitionNode node)
    {
        EmitCSharpAttributes(node.CSharpAttributes);

        var name = SanitizeIdentifier(node.Name);

        // Build type parameters
        var typeParams = "";
        var whereClause = "";
        if (node.TypeParameters.Count > 0)
        {
            typeParams = "<" + string.Join(", ", node.TypeParameters.Select(tp => tp.Name)) + ">";

            // Build where clauses
            var whereClauses = new List<string>();
            foreach (var tp in node.TypeParameters)
            {
                if (tp.Constraints.Count > 0)
                {
                    var constraints = string.Join(", ", tp.Constraints.Select(c => EmitConstraint(c)));
                    whereClauses.Add($"where {tp.Name} : {constraints}");
                }
            }
            if (whereClauses.Count > 0)
            {
                whereClause = " " + string.Join(" ", whereClauses);
            }
        }

        var baseList = node.BaseInterfaces.Count > 0
            ? " : " + string.Join(", ", node.BaseInterfaces)
            : "";

        AppendLine($"public interface {name}{typeParams}{baseList}{whereClause}");
        AppendLine("{");
        Indent();

        foreach (var method in node.Methods)
        {
            Visit(method);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(MethodSignatureNode node)
    {
        // Emit XML comments for contracts
        if (node.HasContracts)
        {
            AppendLine("/// <summary>");
            AppendLine($"/// Interface method with contracts.");
            AppendLine("/// </summary>");

            foreach (var requires in node.Preconditions)
            {
                var condition = requires.Condition.Accept(this);
                AppendLine($"/// <remarks>Requires: {condition}</remarks>");
            }

            foreach (var ensures in node.Postconditions)
            {
                var condition = ensures.Condition.Accept(this);
                AppendLine($"/// <remarks>Ensures: {condition}</remarks>");
            }
        }

        EmitCSharpAttributes(node.CSharpAttributes);

        var returnType = node.Output?.TypeName ?? "void";
        var mappedReturnType = MapTypeName(returnType);
        var methodName = SanitizeIdentifier(node.Name);

        var typeParams = "";
        var whereClause = "";
        if (node.TypeParameters.Count > 0)
        {
            typeParams = "<" + string.Join(", ", node.TypeParameters.Select(tp => tp.Name)) + ">";

            // Build where clauses
            var whereClauses = new List<string>();
            foreach (var tp in node.TypeParameters)
            {
                if (tp.Constraints.Count > 0)
                {
                    var constraints = string.Join(", ", tp.Constraints.Select(c => EmitConstraint(c)));
                    whereClauses.Add($"where {tp.Name} : {constraints}");
                }
            }
            if (whereClauses.Count > 0)
            {
                whereClause = " " + string.Join(" ", whereClauses);
            }
        }

        var parameters = string.Join(", ", node.Parameters.Select(p =>
            $"{MapTypeName(p.TypeName)} {SanitizeIdentifier(p.Name)}"));

        AppendLine($"{mappedReturnType} {methodName}{typeParams}({parameters}){whereClause};");

        return "";
    }

    public string Visit(ClassDefinitionNode node)
    {
        EmitCSharpAttributes(node.CSharpAttributes);

        var name = SanitizeIdentifier(node.Name);

        var modifiers = "public";
        if (node.IsAbstract) modifiers += " abstract";
        if (!node.IsStruct && node.IsSealed) modifiers += " sealed";
        if (node.IsStatic) modifiers += " static";
        if (node.IsReadOnly) modifiers += " readonly";

        var keyword = node.IsStruct ? "struct" : "class";

        // Build type parameters
        var typeParams = "";
        var whereClause = "";
        if (node.TypeParameters.Count > 0)
        {
            typeParams = "<" + string.Join(", ", node.TypeParameters.Select(tp => tp.Name)) + ">";

            var whereClauses = new List<string>();
            foreach (var tp in node.TypeParameters)
            {
                if (tp.Constraints.Count > 0)
                {
                    var constraints = string.Join(", ", tp.Constraints.Select(c => EmitConstraint(c)));
                    whereClauses.Add($"where {tp.Name} : {constraints}");
                }
            }
            if (whereClauses.Count > 0)
            {
                whereClause = " " + string.Join(" ", whereClauses);
            }
        }

        // Build inheritance list
        var baseList = new List<string>();
        if (!string.IsNullOrEmpty(node.BaseClass))
        {
            baseList.Add(node.BaseClass);
        }
        baseList.AddRange(node.ImplementedInterfaces);
        var inheritance = baseList.Count > 0 ? " : " + string.Join(", ", baseList) : "";

        AppendLine($"{modifiers} {keyword} {name}{typeParams}{inheritance}{whereClause}");
        AppendLine("{");
        Indent();

        // Set current class name for constructor emission
        _currentClassName = name;

        // Emit fields
        foreach (var field in node.Fields)
        {
            Visit(field);
        }

        // Emit properties
        foreach (var prop in node.Properties)
        {
            Visit(prop);
            AppendLine();
        }

        // Emit constructors
        foreach (var ctor in node.Constructors)
        {
            Visit(ctor);
            AppendLine();
        }

        // Emit methods
        foreach (var method in node.Methods)
        {
            Visit(method);
            AppendLine();
        }

        // Emit events
        foreach (var evt in node.Events)
        {
            Visit(evt);
        }

        _currentClassName = null;

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(ClassFieldNode node)
    {
        EmitCSharpAttributes(node.CSharpAttributes);

        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "private"
        };

        var parts = new List<string> { visibility };
        if (node.IsStatic) parts.Add("static");
        var fullModifiers = string.Join(" ", parts);

        var typeName = MapTypeName(node.TypeName);
        var fieldName = SanitizeIdentifier(node.Name);

        if (node.DefaultValue != null)
        {
            var defaultVal = node.DefaultValue.Accept(this);
            AppendLine($"{fullModifiers} {typeName} {fieldName} = {defaultVal};");
        }
        else
        {
            AppendLine($"{fullModifiers} {typeName} {fieldName};");
        }

        return "";
    }

    public string Visit(MethodNode node)
    {
        // Clear declared variables tracking for new method scope
        _declaredVariablesInCurrentScope.Clear();

        EmitCSharpAttributes(node.CSharpAttributes);

        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "private"
        };

        var modifiers = new List<string> { visibility };
        if (node.IsStatic) modifiers.Add("static");
        if (node.IsAsync) modifiers.Add("async");
        if (node.IsAbstract) modifiers.Add("abstract");
        else if (node.IsVirtual) modifiers.Add("virtual");
        if (node.IsOverride) modifiers.Add("override");
        if (node.IsSealed && node.IsOverride) modifiers.Add("sealed");

        var returnType = node.Output?.TypeName ?? "void";
        var mappedReturnType = MapTypeName(returnType);
        // Wrap in Task if async
        if (node.IsAsync)
        {
            mappedReturnType = WrapInTask(mappedReturnType);
        }
        var hasReturnValue = returnType.ToUpperInvariant() != "VOID";
        var methodName = SanitizeIdentifier(node.Name);

        // Build type parameters
        var typeParams = "";
        var whereClause = "";
        if (node.TypeParameters.Count > 0)
        {
            typeParams = "<" + string.Join(", ", node.TypeParameters.Select(tp => tp.Name)) + ">";

            var whereClauses = new List<string>();
            foreach (var tp in node.TypeParameters)
            {
                if (tp.Constraints.Count > 0)
                {
                    var constraints = string.Join(", ", tp.Constraints.Select(c => EmitConstraint(c)));
                    whereClauses.Add($"where {tp.Name} : {constraints}");
                }
            }
            if (whereClauses.Count > 0)
            {
                whereClause = " " + string.Join(" ", whereClauses);
            }
        }

        var parameters = string.Join(", ", node.Parameters.Select(p =>
            $"{MapTypeName(p.TypeName)} {SanitizeIdentifier(p.Name)}"));

        // Operator overload detection: op_ prefix methods emit C# operator syntax
        if (node.Name.StartsWith("op_"))
        {
            return EmitOperatorMethod(node, modifiers, mappedReturnType, parameters);
        }

        // Abstract methods have no body
        if (node.IsAbstract)
        {
            AppendLine($"{string.Join(" ", modifiers)} {mappedReturnType} {methodName}{typeParams}({parameters}){whereClause};");
            return "";
        }

        AppendLine($"{string.Join(" ", modifiers)} {mappedReturnType} {methodName}{typeParams}({parameters}){whereClause}");
        AppendLine("{");
        Indent();

        // Check for inherited contracts
        var inheritedContracts = _currentClassName != null && _inheritanceResult != null
            ? _inheritanceResult.GetInheritedContracts(_currentClassName, node.Name)
            : null;

        // Emit explicit preconditions
        foreach (var requires in node.Preconditions)
        {
            var check = Visit(requires);
            AppendLine(check);
        }

        // Emit inherited preconditions (only if method has no explicit contracts)
        if (!node.HasContracts && inheritedContracts != null)
        {
            foreach (var requires in inheritedContracts.Preconditions)
            {
                AppendLine($"// Inherited from {inheritedContracts.InterfaceName}.{inheritedContracts.MethodName}");
                var check = Visit(requires);
                AppendLine(check);
            }
        }

        // Calculate effective postconditions
        var effectivePostconditions = node.Postconditions.Count > 0
            ? node.Postconditions
            : (inheritedContracts?.Postconditions ?? Array.Empty<EnsuresNode>());
        var hasInheritedPostconditions = !node.HasContracts && inheritedContracts != null && inheritedContracts.Postconditions.Count > 0;

        // Handle postconditions similar to FunctionNode
        if (effectivePostconditions.Count > 0 && hasReturnValue)
        {
            AppendLine($"{mappedReturnType} __result__ = default;");
            AppendLine();

            foreach (var statement in node.Body)
            {
                if (statement is ReturnStatementNode returnStmt && returnStmt.Expression != null)
                {
                    var expr = returnStmt.Expression.Accept(this);
                    AppendLine($"__result__ = {expr};");
                }
                else
                {
                    var stmtCode = statement.Accept(this);
                    AppendLine(stmtCode);
                }
            }

            AppendLine();

            // Emit explicit postconditions
            foreach (var ensures in node.Postconditions)
            {
                var check = Visit(ensures).Replace("result", "__result__");
                AppendLine(check);
            }

            // Emit inherited postconditions (only if method has no explicit contracts)
            if (hasInheritedPostconditions)
            {
                foreach (var ensures in inheritedContracts!.Postconditions)
                {
                    AppendLine($"// Inherited from {inheritedContracts.InterfaceName}.{inheritedContracts.MethodName}");
                    var check = Visit(ensures).Replace("result", "__result__");
                    AppendLine(check);
                }
            }

            AppendLine("return __result__;");
        }
        else
        {
            foreach (var statement in node.Body)
            {
                var stmtCode = statement.Accept(this);
                AppendLine(stmtCode);
            }

            foreach (var ensures in node.Postconditions)
            {
                var check = Visit(ensures);
                AppendLine(check);
            }

            // Emit inherited postconditions for void methods
            if (hasInheritedPostconditions)
            {
                foreach (var ensures in inheritedContracts!.Postconditions)
                {
                    AppendLine($"// Inherited from {inheritedContracts.InterfaceName}.{inheritedContracts.MethodName}");
                    var check = Visit(ensures);
                    AppendLine(check);
                }
            }
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    private static readonly Dictionary<string, string> CilNameToOperator = new()
    {
        ["op_Addition"] = "+",
        ["op_Subtraction"] = "-",
        ["op_Multiply"] = "*",
        ["op_Division"] = "/",
        ["op_Modulus"] = "%",
        ["op_Equality"] = "==",
        ["op_Inequality"] = "!=",
        ["op_LessThan"] = "<",
        ["op_GreaterThan"] = ">",
        ["op_LessThanOrEqual"] = "<=",
        ["op_GreaterThanOrEqual"] = ">=",
        ["op_UnaryNegation"] = "-",
        ["op_UnaryPlus"] = "+",
        ["op_LogicalNot"] = "!",
        ["op_BitwiseAnd"] = "&",
        ["op_BitwiseOr"] = "|",
        ["op_ExclusiveOr"] = "^",
    };

    private string EmitOperatorMethod(MethodNode node, List<string> modifiers, string mappedReturnType, string parameters)
    {
        var modStr = string.Join(" ", modifiers);

        if (node.Name == "op_Implicit")
        {
            AppendLine($"{modStr} implicit operator {mappedReturnType}({parameters})");
        }
        else if (node.Name == "op_Explicit")
        {
            AppendLine($"{modStr} explicit operator {mappedReturnType}({parameters})");
        }
        else if (CilNameToOperator.TryGetValue(node.Name, out var op))
        {
            AppendLine($"{modStr} {mappedReturnType} operator {op}({parameters})");
        }
        else
        {
            // Unknown operator â fall back to regular method
            AppendLine($"{modStr} {mappedReturnType} {SanitizeIdentifier(node.Name)}({parameters})");
        }

        AppendLine("{");
        Indent();

        // Emit explicit preconditions
        foreach (var requires in node.Preconditions)
        {
            var check = Visit(requires);
            AppendLine(check);
        }

        var returnType = node.Output?.TypeName ?? "void";
        var hasReturnValue = returnType.ToUpperInvariant() != "VOID";

        // Handle postconditions
        if (node.Postconditions.Count > 0 && hasReturnValue)
        {
            AppendLine($"{mappedReturnType} __result__ = default;");
            AppendLine();

            foreach (var statement in node.Body)
            {
                if (statement is ReturnStatementNode returnStmt && returnStmt.Expression != null)
                {
                    var expr = returnStmt.Expression.Accept(this);
                    AppendLine($"__result__ = {expr};");
                }
                else
                {
                    var stmtCode = statement.Accept(this);
                    AppendLine(stmtCode);
                }
            }

            AppendLine();

            foreach (var ensures in node.Postconditions)
            {
                var check = Visit(ensures).Replace("result", "__result__");
                AppendLine(check);
            }

            AppendLine("return __result__;");
        }
        else
        {
            foreach (var statement in node.Body)
            {
                var stmtCode = statement.Accept(this);
                AppendLine(stmtCode);
            }

            foreach (var ensures in node.Postconditions)
            {
                var check = Visit(ensures);
                AppendLine(check);
            }
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(NewExpressionNode node)
    {
        var typeName = SanitizeIdentifier(node.TypeName);
        if (node.TypeArguments.Count > 0)
        {
            typeName += "<" + string.Join(", ", node.TypeArguments.Select(MapTypeName)) + ">";
        }

        var args = string.Join(", ", node.Arguments.Select(a => a.Accept(this)));
        var result = $"new {typeName}({args})";
        if (node.Initializers.Count > 0)
        {
            var inits = string.Join(", ", node.Initializers.Select(
                i => $"{i.PropertyName} = {i.Value.Accept(this)}"));
            result = $"new {typeName}({args}) {{ {inits} }}";
        }
        return result;
    }

    public string Visit(CallExpressionNode node)
    {
        // Unescape braces that were escaped for Calor syntax: \{ -> { and \} -> }
        var target = UnescapeBraces(node.Target);
        var args = string.Join(", ", node.Arguments.Select(a => a.Accept(this)));
        return $"{target}({args})";
    }

    /// <summary>
    /// Unescapes braces that were escaped for Calor syntax.
    /// \{ becomes { and \} becomes }
    /// </summary>
    private static string UnescapeBraces(string input)
    {
        if (!input.Contains('\\'))
            return input;

        return input.Replace("\\{", "{").Replace("\\}", "}");
    }

    public string Visit(ThisExpressionNode node)
    {
        return "this";
    }

    public string Visit(BaseExpressionNode node)
    {
        return "base";
    }

    // Phase 9: Properties and Constructors

    public string Visit(PropertyNode node)
    {
        EmitCSharpAttributes(node.CSharpAttributes);

        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "public"
        };

        var modifiers = new List<string> { visibility };
        if (node.IsStatic) modifiers.Add("static");
        if (node.IsAbstract) modifiers.Add("abstract");
        else if (node.IsVirtual) modifiers.Add("virtual");
        if (node.IsOverride) modifiers.Add("override");
        if (node.IsSealed && node.IsOverride) modifiers.Add("sealed");

        var modifierStr = string.Join(" ", modifiers);
        var typeName = MapTypeName(node.TypeName);
        var propName = SanitizeIdentifier(node.Name);

        // Auto-property with default value
        if (node.IsAutoProperty)
        {
            if (node.DefaultValue != null)
            {
                var defaultVal = node.DefaultValue.Accept(this);
                AppendLine($"{modifierStr} {typeName} {propName} {{ get; set; }} = {defaultVal};");
            }
            else
            {
                AppendLine($"{modifierStr} {typeName} {propName} {{ get; set; }}");
            }
            return "";
        }

        // Property with accessors
        AppendLine($"{modifierStr} {typeName} {propName}");
        AppendLine("{");
        Indent();

        if (node.Getter != null)
        {
            Visit(node.Getter);
        }

        if (node.Setter != null)
        {
            Visit(node.Setter);
        }

        if (node.Initer != null)
        {
            Visit(node.Initer);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(PropertyAccessorNode node)
    {
        var accessorKeyword = node.Kind switch
        {
            PropertyAccessorNode.AccessorKind.Get => "get",
            PropertyAccessorNode.AccessorKind.Set => "set",
            PropertyAccessorNode.AccessorKind.Init => "init",
            _ => "get"
        };

        var visibilityPrefix = node.Visibility switch
        {
            Visibility.Private => "private ",
            Visibility.Internal => "internal ",
            Visibility.Protected => "protected ",
            _ => ""
        };

        if (node.IsAutoImplemented)
        {
            AppendLine($"{visibilityPrefix}{accessorKeyword};");
        }
        else
        {
            // Clear declared variables tracking for new accessor scope
            _declaredVariablesInCurrentScope.Clear();

            AppendLine($"{visibilityPrefix}{accessorKeyword}");
            AppendLine("{");
            Indent();

            foreach (var pre in node.Preconditions)
            {
                AppendLine(Visit(pre));
            }

            foreach (var stmt in node.Body)
            {
                AppendLine(stmt.Accept(this));
            }

            Dedent();
            AppendLine("}");
        }

        return "";
    }

    public string Visit(ConstructorNode node)
    {
        // Clear declared variables tracking for new constructor scope
        _declaredVariablesInCurrentScope.Clear();

        EmitCSharpAttributes(node.CSharpAttributes);

        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "public"
        };

        // Constructor name is the class name
        var ctorName = _currentClassName ?? "UnknownClass";
        var parameters = string.Join(", ", node.Parameters.Select(p =>
            $"{MapTypeName(p.TypeName)} {SanitizeIdentifier(p.Name)}"));

        var initializerStr = "";
        if (node.Initializer != null)
        {
            var initArgs = string.Join(", ", node.Initializer.Arguments.Select(a => a.Accept(this)));
            initializerStr = node.Initializer.IsBaseCall ? $" : base({initArgs})" : $" : this({initArgs})";
        }

        AppendLine($"{visibility} {ctorName}({parameters}){initializerStr}");
        AppendLine("{");
        Indent();

        foreach (var pre in node.Preconditions)
        {
            AppendLine(Visit(pre));
        }

        foreach (var stmt in node.Body)
        {
            AppendLine(stmt.Accept(this));
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(ConstructorInitializerNode node)
    {
        var args = string.Join(", ", node.Arguments.Select(a => a.Accept(this)));
        return node.IsBaseCall ? $"base({args})" : $"this({args})";
    }

    public string Visit(AssignmentStatementNode node)
    {
        var target = node.Target.Accept(this);
        var value = node.Value.Accept(this);
        return $"{target} = {value};";
    }

    public string Visit(CompoundAssignmentStatementNode node)
    {
        var target = node.Target.Accept(this);
        var value = node.Value.Accept(this);
        var op = node.Operator switch
        {
            CompoundAssignmentOperator.Add => "+=",
            CompoundAssignmentOperator.Subtract => "-=",
            CompoundAssignmentOperator.Multiply => "*=",
            CompoundAssignmentOperator.Divide => "/=",
            CompoundAssignmentOperator.Modulo => "%=",
            CompoundAssignmentOperator.BitwiseAnd => "&=",
            CompoundAssignmentOperator.BitwiseOr => "|=",
            CompoundAssignmentOperator.BitwiseXor => "^=",
            CompoundAssignmentOperator.LeftShift => "<<=",
            CompoundAssignmentOperator.RightShift => ">>=",
            _ => "+="
        };
        return $"{target} {op} {value};";
    }

    public string Visit(UsingStatementNode node)
    {
        var typePart = node.VariableType != null ? MapTypeName(node.VariableType) : "var";
        var namePart = node.VariableName != null ? SanitizeIdentifier(node.VariableName) : "_";
        var resource = node.Resource.Accept(this);

        AppendLine($"using ({typePart} {namePart} = {resource})");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            AppendLine(stmt.Accept(this));
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    // Phase 10: Try/Catch/Finally

    public string Visit(TryStatementNode node)
    {
        AppendLine("try");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.TryBody)
        {
            AppendLine(stmt.Accept(this));
        }

        Dedent();
        AppendLine("}");

        foreach (var catchClause in node.CatchClauses)
        {
            Visit(catchClause);
        }

        if (node.FinallyBody != null)
        {
            AppendLine("finally");
            AppendLine("{");
            Indent();

            foreach (var stmt in node.FinallyBody)
            {
                AppendLine(stmt.Accept(this));
            }

            Dedent();
            AppendLine("}");
        }

        return "";
    }

    public string Visit(CatchClauseNode node)
    {
        var catchPart = "catch";
        if (node.ExceptionType != null)
        {
            var exType = SanitizeIdentifier(node.ExceptionType);
            if (node.VariableName != null)
            {
                var varName = SanitizeIdentifier(node.VariableName);
                catchPart = $"catch ({exType} {varName})";
            }
            else
            {
                catchPart = $"catch ({exType})";
            }
        }

        if (node.Filter != null)
        {
            var filter = node.Filter.Accept(this);
            catchPart += $" when ({filter})";
        }

        AppendLine(catchPart);
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            AppendLine(stmt.Accept(this));
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(ThrowStatementNode node)
    {
        if (node.Exception != null)
        {
            var exception = node.Exception.Accept(this);
            return $"throw {exception};";
        }
        return "throw;";
    }

    public string Visit(RethrowStatementNode node)
    {
        return "throw;";
    }

    // Phase 11: Lambdas, Delegates, Events

    public string Visit(LambdaParameterNode node)
    {
        if (node.TypeName != null)
        {
            return $"{MapTypeName(node.TypeName)} {SanitizeIdentifier(node.Name)}";
        }
        return SanitizeIdentifier(node.Name);
    }

    public string Visit(LambdaExpressionNode node)
    {
        var async = node.IsAsync ? "async " : "";
        var parameters = node.Parameters.Count switch
        {
            0 => "()",
            1 when node.Parameters[0].TypeName == null => SanitizeIdentifier(node.Parameters[0].Name),
            _ => "(" + string.Join(", ", node.Parameters.Select(p => Visit(p))) + ")"
        };

        if (node.IsExpressionLambda && node.ExpressionBody != null)
        {
            var body = node.ExpressionBody.Accept(this);
            return $"{async}{parameters} => {body}";
        }
        else if (node.StatementBody != null && node.StatementBody.Count > 0)
        {
            var sb = new StringBuilder();
            sb.Append($"{async}{parameters} => {{\n");
            foreach (var stmt in node.StatementBody)
            {
                sb.Append($"    {stmt.Accept(this)}\n");
            }
            sb.Append("}");
            return sb.ToString();
        }

        return $"{async}{parameters} => default";
    }

    public string Visit(DelegateDefinitionNode node)
    {
        var name = SanitizeIdentifier(node.Name);
        var returnType = node.Output?.TypeName ?? "void";
        var mappedReturnType = MapTypeName(returnType);
        var parameters = string.Join(", ", node.Parameters.Select(p =>
            $"{MapTypeName(p.TypeName)} {SanitizeIdentifier(p.Name)}"));

        AppendLine($"public delegate {mappedReturnType} {name}({parameters});");
        return "";
    }

    public string Visit(EventDefinitionNode node)
    {
        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "public"
        };

        var eventName = SanitizeIdentifier(node.Name);
        var delegateType = SanitizeIdentifier(node.DelegateType);

        AppendLine($"{visibility} event {delegateType} {eventName};");
        return "";
    }

    public string Visit(EventSubscribeNode node)
    {
        var @event = node.Event.Accept(this);
        var handler = node.Handler.Accept(this);
        return $"{@event} += {handler};";
    }

    public string Visit(EventUnsubscribeNode node)
    {
        var @event = node.Event.Accept(this);
        var handler = node.Handler.Accept(this);
        return $"{@event} -= {handler};";
    }

    // Phase 12: Async/Await

    public string Visit(AwaitExpressionNode node)
    {
        var awaited = node.Awaited.Accept(this);

        // Handle ConfigureAwait if specified
        if (node.ConfigureAwait.HasValue)
        {
            var configValue = node.ConfigureAwait.Value ? "true" : "false";
            return $"await {awaited}.ConfigureAwait({configValue})";
        }

        return $"await {awaited}";
    }

    // Phase 9: String Interpolation and Modern Operators

    public string Visit(InterpolatedStringNode node)
    {
        var sb = new StringBuilder();
        sb.Append("$\"");

        foreach (var part in node.Parts)
        {
            if (part is InterpolatedStringTextNode textPart)
            {
                // Escape quotes and braces in literal text
                var escaped = textPart.Text
                    .Replace("\\", "\\\\")
                    .Replace("\"", "\\\"")
                    .Replace("{", "{{")
                    .Replace("}", "}}");
                sb.Append(escaped);
            }
            else if (part is InterpolatedStringExpressionNode exprPart)
            {
                sb.Append("{");
                sb.Append(exprPart.Expression.Accept(this));
                sb.Append("}");
            }
        }

        sb.Append("\"");
        return sb.ToString();
    }

    public string Visit(InterpolatedStringTextNode node)
    {
        // This is typically only called standalone, not as part of interpolation
        return node.Text;
    }

    public string Visit(InterpolatedStringExpressionNode node)
    {
        // This is typically only called standalone, not as part of interpolation
        return node.Expression.Accept(this);
    }

    public string Visit(NullCoalesceNode node)
    {
        var left = node.Left.Accept(this);
        var right = node.Right.Accept(this);
        return $"{left} ?? {right}";
    }

    public string Visit(NullConditionalNode node)
    {
        var target = node.Target.Accept(this);
        return $"{target}?.{SanitizeIdentifier(node.MemberName)}";
    }

    public string Visit(RangeExpressionNode node)
    {
        var start = node.Start?.Accept(this) ?? "";
        var end = node.End?.Accept(this) ?? "";
        return $"{start}..{end}";
    }

    public string Visit(IndexFromEndNode node)
    {
        var offset = node.Offset.Accept(this);
        return $"^{offset}";
    }

    // Phase 10: Advanced Patterns

    public string Visit(WithExpressionNode node)
    {
        var target = node.Target.Accept(this);
        var assignments = string.Join(", ", node.Assignments.Select(a =>
            $"{SanitizeIdentifier(a.PropertyName)} = {a.Value.Accept(this)}"));
        return $"{target} with {{ {assignments} }}";
    }

    public string Visit(WithPropertyAssignmentNode node)
    {
        var value = node.Value.Accept(this);
        return $"{SanitizeIdentifier(node.PropertyName)} = {value}";
    }

    public string Visit(PositionalPatternNode node)
    {
        var patterns = string.Join(", ", node.Patterns.Select(p => p.Accept(this)));
        return $"{SanitizeIdentifier(node.TypeName)}({patterns})";
    }

    public string Visit(PropertyPatternNode node)
    {
        var matches = string.Join(", ", node.Matches.Select(m => m.Accept(this)));
        var typePart = string.IsNullOrEmpty(node.TypeName) ? "" : SanitizeIdentifier(node.TypeName) + " ";
        return $"{typePart}{{ {matches} }}";
    }

    public string Visit(PropertyMatchNode node)
    {
        var pattern = node.Pattern.Accept(this);
        return $"{SanitizeIdentifier(node.PropertyName)}: {pattern}";
    }

    public string Visit(RelationalPatternNode node)
    {
        var value = node.Value.Accept(this);
        var op = node.Operator.ToLowerInvariant() switch
        {
            "lt" => "<",
            "lte" => "<=",
            "gt" => ">",
            "gte" => ">=",
            "eq" => "",
            _ => node.Operator
        };
        return string.IsNullOrEmpty(op) ? value : $"{op} {value}";
    }

    public string Visit(ListPatternNode node)
    {
        var parts = new List<string>();
        foreach (var pattern in node.Patterns)
        {
            parts.Add(pattern.Accept(this));
        }
        if (node.SlicePattern != null)
        {
            parts.Add($"..{node.SlicePattern.Accept(this)}");
        }
        return $"[{string.Join(", ", parts)}]";
    }

    public string Visit(VarPatternNode node)
    {
        return $"var {SanitizeIdentifier(node.Name)}";
    }

    public string Visit(ConstantPatternNode node)
    {
        return node.Value.Accept(this);
    }

    #region Extended Features Visit Methods

    /// <summary>
    /// Emits Debug.Assert for an inline example/test.
    /// </summary>
    public string Visit(ExampleNode node)
    {
        var expr = node.Expression.Accept(this);
        var expected = node.Expected.Accept(this);
        var message = node.Message ?? $"Example {node.Id ?? ""}";
        return $"System.Diagnostics.Debug.Assert(object.Equals({expr}, {expected}), \"{EscapeString(message)}\");";
    }

    /// <summary>
    /// Emits a structured comment for issues (TODO, FIXME, HACK).
    /// </summary>
    public string Visit(IssueNode node)
    {
        var idPart = node.Id != null ? $"[{node.Id}]" : "";
        var categoryPart = node.Category != null ? $"({node.Category})" : "";
        var priorityPart = node.Priority != IssuePriority.Medium ? $" [{node.Priority}]" : "";
        return $"// {node.Kind.ToString().ToUpperInvariant()}{idPart}{categoryPart}{priorityPart}: {node.Description}";
    }

    /// <summary>
    /// Emits nothing for dependency nodes (used as part of Uses/UsedBy).
    /// </summary>
    public string Visit(DependencyNode node)
    {
        var versionPart = node.Version != null ? $"@{node.Version}" : "";
        var optionalPart = node.IsOptional ? "?" : "";
        return $"{node.Target}{versionPart}{optionalPart}";
    }

    /// <summary>
    /// Emits a comment for USES declarations.
    /// </summary>
    public string Visit(UsesNode node)
    {
        if (node.Dependencies.Count == 0)
            return "";

        var deps = string.Join(", ", node.Dependencies.Select(d => d.Accept(this)));
        return $"// USES: {deps}";
    }

    /// <summary>
    /// Emits a comment for USEDBY declarations.
    /// </summary>
    public string Visit(UsedByNode node)
    {
        if (node.Dependents.Count == 0 && !node.HasUnknownCallers)
            return "";

        var deps = string.Join(", ", node.Dependents.Select(d => d.Accept(this)));
        var unknownPart = node.HasUnknownCallers ? (deps.Length > 0 ? ", [external]" : "[external]") : "";
        return $"// USEDBY: {deps}{unknownPart}";
    }

    /// <summary>
    /// Emits a comment for ASSUME declarations.
    /// </summary>
    public string Visit(AssumeNode node)
    {
        var categoryPart = node.Category.HasValue ? $"[{node.Category.Value.ToString().ToLowerInvariant()}]" : "";
        return $"// ASSUME{categoryPart}: {node.Description}";
    }

    /// <summary>
    /// Emits a comment for COMPLEXITY declarations.
    /// </summary>
    public string Visit(ComplexityNode node)
    {
        var parts = new List<string>();
        var prefix = node.IsWorstCase ? "Worst-case " : "";

        if (node.TimeComplexity.HasValue)
            parts.Add($"time: {FormatComplexity(node.TimeComplexity.Value)}");
        if (node.SpaceComplexity.HasValue)
            parts.Add($"space: {FormatComplexity(node.SpaceComplexity.Value)}");
        if (node.CustomExpression != null)
            parts.Add(node.CustomExpression);

        if (parts.Count == 0)
            return "";

        return $"// COMPLEXITY: {prefix}{string.Join(", ", parts)}";
    }

    private static string FormatComplexity(ComplexityClass c)
    {
        return c switch
        {
            ComplexityClass.O1 => "O(1)",
            ComplexityClass.OLogN => "O(log n)",
            ComplexityClass.ON => "O(n)",
            ComplexityClass.ONLogN => "O(n log n)",
            ComplexityClass.ON2 => "O(nÂ²)",
            ComplexityClass.ON3 => "O(nÂ³)",
            ComplexityClass.O2N => "O(2â¿)",
            ComplexityClass.ONFact => "O(n!)",
            _ => c.ToString()
        };
    }

    /// <summary>
    /// Emits a comment for SINCE declarations.
    /// </summary>
    public string Visit(SinceNode node)
    {
        return $"// SINCE: {node.Version}";
    }

    /// <summary>
    /// Emits an [Obsolete] attribute for DEPRECATED declarations.
    /// </summary>
    public string Visit(DeprecatedNode node)
    {
        var parts = new List<string>();
        parts.Add($"Deprecated since {node.SinceVersion}");

        if (node.Replacement != null)
            parts.Add($"Use {node.Replacement} instead");
        if (node.Reason != null)
            parts.Add(node.Reason);
        if (node.RemovedInVersion != null)
            parts.Add($"Will be removed in {node.RemovedInVersion}");

        var message = string.Join(". ", parts);
        return $"[System.Obsolete(\"{EscapeString(message)}\")]";
    }

    /// <summary>
    /// Emits a comment for BREAKING declarations.
    /// </summary>
    public string Visit(BreakingChangeNode node)
    {
        return $"// BREAKING CHANGE ({node.Version}): {node.Description}";
    }

    /// <summary>
    /// Emits documentation comment for a DECISION record.
    /// </summary>
    public string Visit(DecisionNode node)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"// DECISION[{node.Id}]: {node.Title}");
        sb.AppendLine($"// Chosen: {node.ChosenOption}");
        foreach (var reason in node.ChosenReasons)
        {
            sb.AppendLine($"//   Reason: {reason}");
        }
        foreach (var rejected in node.RejectedOptions)
        {
            var rejectedText = Visit(rejected);
            foreach (var line in rejectedText.Split('\n'))
            {
                sb.AppendLine(line);
            }
        }
        if (node.Context != null)
            sb.AppendLine($"// Context: {node.Context}");
        if (node.Date.HasValue)
            sb.AppendLine($"// Date: {node.Date.Value:yyyy-MM-dd}");
        if (node.Author != null)
            sb.AppendLine($"// Author: {node.Author}");

        return sb.ToString().TrimEnd();
    }

    /// <summary>
    /// Emits documentation for a rejected option in a decision record.
    /// </summary>
    public string Visit(RejectedOptionNode node)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"// Rejected: {node.Name}");
        foreach (var reason in node.Reasons)
        {
            sb.AppendLine($"//   Reason: {reason}");
        }
        return sb.ToString().TrimEnd();
    }

    /// <summary>
    /// Emits a comment for CONTEXT partial view markers.
    /// </summary>
    public string Visit(ContextNode node)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"// CONTEXT{(node.IsPartial ? " (partial)" : "")}");

        if (node.VisibleFiles.Count > 0)
        {
            sb.AppendLine("// Visible:");
            foreach (var file in node.VisibleFiles)
            {
                sb.AppendLine($"//   - {file.FilePath}{(file.Description != null ? $" ({file.Description})" : "")}");
            }
        }

        if (node.HiddenFiles.Count > 0)
        {
            sb.AppendLine("// Hidden:");
            foreach (var file in node.HiddenFiles)
            {
                sb.AppendLine($"//   - {file.FilePath}{(file.Description != null ? $" ({file.Description})" : "")}");
            }
        }

        if (node.FocusTarget != null)
            sb.AppendLine($"// Focus: {node.FocusTarget}");

        return sb.ToString().TrimEnd();
    }

    /// <summary>
    /// Emits a comment for FILE references.
    /// </summary>
    public string Visit(FileRefNode node)
    {
        var descPart = node.Description != null ? $" ({node.Description})" : "";
        return $"// FILE: {node.FilePath}{descPart}";
    }

    /// <summary>
    /// Emits a property-based test method stub.
    /// </summary>
    public string Visit(PropertyTestNode node)
    {
        var quantifiers = node.Quantifiers.Count > 0
            ? $"â{string.Join(",", node.Quantifiers)}: "
            : "";
        var predicate = node.Predicate.Accept(this);
        return $"// PROPERTY: {quantifiers}{predicate}";
    }

    /// <summary>
    /// Emits a comment for LOCK declarations.
    /// </summary>
    public string Visit(LockNode node)
    {
        var parts = new List<string> { $"agent={node.AgentId}" };
        if (node.Acquired.HasValue)
            parts.Add($"acquired={node.Acquired.Value:O}");
        if (node.Expires.HasValue)
            parts.Add($"expires={node.Expires.Value:O}");

        return $"// LOCK: {string.Join(", ", parts)}";
    }

    /// <summary>
    /// Emits a comment for AUTHOR declarations.
    /// </summary>
    public string Visit(AuthorNode node)
    {
        var parts = new List<string> { $"agent={node.AgentId}", $"date={node.Date:yyyy-MM-dd}" };
        if (node.TaskId != null)
            parts.Add($"task={node.TaskId}");

        return $"// AUTHOR: {string.Join(", ", parts)}";
    }

    /// <summary>
    /// Emits a comment for TASK references.
    /// </summary>
    public string Visit(TaskRefNode node)
    {
        return $"// TASK[{node.TaskId}]: {node.Description}";
    }

    #endregion

    private string GetInferredTypeName(ExpressionNode expr)
    {
        return expr switch
        {
            IntLiteralNode => "int",
            FloatLiteralNode => "double",
            BoolLiteralNode => "bool",
            StringLiteralNode => "string",
            _ => "object"
        };
    }

    private static string MapTypeName(string calorType)
    {
        // Use the centralized TypeMapper for bidirectional type mapping
        return TypeMapper.CalorToCSharp(calorType);
    }

    /// <summary>
    /// Wraps a return type in Task for async methods.
    /// </summary>
    private static string WrapInTask(string returnType)
    {
        // Don't double-wrap types that are already Task/ValueTask
        if (returnType.StartsWith("Task<", StringComparison.Ordinal) ||
            returnType == "Task" ||
            returnType.StartsWith("ValueTask<", StringComparison.Ordinal) ||
            returnType == "ValueTask")
        {
            return returnType;
        }

        // void -> Task, T -> Task<T>
        return returnType == "void" ? "Task" : $"Task<{returnType}>";
    }

    private static string SanitizeIdentifier(string name)
    {
        // Replace any characters that aren't valid in C# identifiers
        var sb = new StringBuilder();
        for (int i = 0; i < name.Length; i++)
        {
            var c = name[i];
            if (char.IsLetterOrDigit(c) || c == '_')
            {
                sb.Append(c);
            }
            else if (c == '.')
            {
                sb.Append('_');
            }
        }

        var result = sb.ToString();

        // Ensure identifier doesn't start with a digit
        if (result.Length > 0 && char.IsDigit(result[0]))
        {
            result = "_" + result;
        }

        // Handle reserved words
        return result switch
        {
            "class" or "struct" or "interface" or "enum" or
            "namespace" or "using" or "public" or "private" or
            "protected" or "internal" or "static" or "void" or
            "int" or "string" or "bool" or "float" or "double" or
            "return" or "if" or "else" or "for" or "while" or
            "do" or "switch" or "case" or "break" or "continue" or
            "new" or "this" or "base" or "null" or "true" or "false"
            => "@" + result,
            _ => result
        };
    }

    private static string SanitizeNamespace(string name)
    {
        var sb = new StringBuilder();
        for (int i = 0; i < name.Length; i++)
        {
            var c = name[i];
            if (char.IsLetterOrDigit(c) || c == '_' || c == '.')
            {
                sb.Append(c);
            }
        }

        var result = sb.ToString();
        if (result.Length > 0 && char.IsDigit(result[0]))
        {
            result = "_" + result;
        }
        return result;
    }

    /// <summary>
    /// Emits C#-style attributes.
    /// </summary>
    private void EmitCSharpAttributes(IReadOnlyList<CalorAttributeNode> attributes)
    {
        foreach (var attr in attributes)
        {
            AppendLine(Visit(attr));
        }
    }

    public string Visit(CalorAttributeNode node)
    {
        if (node.Arguments.Count == 0)
        {
            return $"[{node.Name}]";
        }

        var args = string.Join(", ", node.Arguments.Select(FormatCSharpAttributeArgument));
        return $"[{node.Name}({args})]";
    }

    private static string FormatCSharpAttributeArgument(CalorAttributeArgument arg)
    {
        var value = arg.GetFormattedValue();

        if (arg.IsNamed)
        {
            return $"{arg.Name} = {value}";
        }
        return value;
    }

    // Quantified Contracts

    public string Visit(QuantifierVariableNode node)
    {
        // Variable nodes are handled internally by quantifier translation
        return $"{node.Name}: {node.TypeName}";
    }

    public string Visit(ForallExpressionNode node)
    {
        // Try to extract finite range from the pattern:
        // (forall ((i type)) (-> (&& (>= i 0) (< i n)) body))
        var range = TryExtractFiniteRange(node);
        if (range != null)
        {
            // Generate loop-based check - support multiple bound variables
            if (range.AllRanges.Count > 1)
            {
                // Generate nested Enumerable.Range().All() calls for multiple variables
                // e.g., Enumerable.Range(0, n).All(i => Enumerable.Range(0, m).All(j => body))
                var body = range.Body.Accept(this);
                var result = body;

                // Build from innermost to outermost
                for (int i = range.AllRanges.Count - 1; i >= 0; i--)
                {
                    var varRange = range.AllRanges[i];
                    var varName = SanitizeIdentifier(varRange.Name);
                    result = $"Enumerable.Range({varRange.Start}, {varRange.End} - {varRange.Start}).All({varName} => ({result}))";
                }
                return result;
            }
            else
            {
                // Single variable - original behavior
                var varName = SanitizeIdentifier(node.BoundVariables[0].Name);
                var body = range.Body.Accept(this);
                return $"Enumerable.Range({range.Start}, {range.End} - {range.Start}).All({varName} => ({body}))";
            }
        }

        // For infinite domains or unrecognized patterns, emit static-only verification
        // Supported pattern: (forall ((var type)) (-> (&& (>= var lower) (< var upper)) body))
        var boundVarsStr = string.Join(", ", node.BoundVariables.Select(bv => $"{bv.Name}: {bv.TypeName}"));
        var bodyStr = node.Body.Accept(this);
        var hint = node.Body is not ImplicationExpressionNode
            ? " [Hint: Use implication pattern (-> bounds body) for runtime checking]"
            : " [Hint: Could not extract finite bounds from antecedent]";
        return $"true /* STATIC ONLY: forall (({boundVarsStr})) - verified by Z3.{hint} */";
    }

    public string Visit(ExistsExpressionNode node)
    {
        // Try to extract finite range from the pattern:
        // (exists ((i type)) (&& (>= i 0) (< i n) body))
        var range = TryExtractFiniteRangeForExists(node);
        if (range != null)
        {
            // Generate Any-based check - support multiple bound variables
            if (range.AllRanges.Count > 1)
            {
                // Generate nested Enumerable.Range().Any() calls for multiple variables
                // e.g., Enumerable.Range(0, n).Any(i => Enumerable.Range(0, m).Any(j => body))
                var body = range.Body.Accept(this);
                var result = body;

                // Build from innermost to outermost
                for (int i = range.AllRanges.Count - 1; i >= 0; i--)
                {
                    var varRange = range.AllRanges[i];
                    var varName = SanitizeIdentifier(varRange.Name);
                    result = $"Enumerable.Range({varRange.Start}, {varRange.End} - {varRange.Start}).Any({varName} => ({result}))";
                }
                return result;
            }
            else
            {
                // Single variable - original behavior
                var varName = SanitizeIdentifier(node.BoundVariables[0].Name);
                var body = range.Body.Accept(this);
                return $"Enumerable.Range({range.Start}, {range.End} - {range.Start}).Any({varName} => ({body}))";
            }
        }

        // For infinite domains or unrecognized patterns, emit static-only verification
        // Supported pattern: (exists ((var type)) (&& (>= var lower) (< var upper) body))
        var boundVarsStr = string.Join(", ", node.BoundVariables.Select(bv => $"{bv.Name}: {bv.TypeName}"));
        var hint = " [Hint: Use conjunction pattern (&& bounds body) for runtime checking]";
        return $"false /* STATIC ONLY: exists (({boundVarsStr})) - verified by Z3.{hint} */";
    }

    public string Visit(ImplicationExpressionNode node)
    {
        // p -> q is equivalent to !p || q
        var ante = node.Antecedent.Accept(this);
        var cons = node.Consequent.Accept(this);
        return $"(!({ante}) || ({cons}))";
    }

    // Native String Operations

    public string Visit(StringOperationNode node)
    {
        var args = node.Arguments.Select(a => a.Accept(this)).ToList();
        var compMode = node.ComparisonMode?.ToCSharpName();

        return node.Operation switch
        {
            // Instance methods - Query operations (with optional comparison mode)
            StringOp.Length => $"{args[0]}.Length",
            StringOp.Contains when compMode != null => $"{args[0]}.Contains({args[1]}, {compMode})",
            StringOp.Contains => $"{args[0]}.Contains({args[1]})",
            StringOp.StartsWith when compMode != null => $"{args[0]}.StartsWith({args[1]}, {compMode})",
            StringOp.StartsWith => $"{args[0]}.StartsWith({args[1]})",
            StringOp.EndsWith when compMode != null => $"{args[0]}.EndsWith({args[1]}, {compMode})",
            StringOp.EndsWith => $"{args[0]}.EndsWith({args[1]})",
            StringOp.IndexOf when compMode != null => $"{args[0]}.IndexOf({args[1]}, {compMode})",
            StringOp.IndexOf => $"{args[0]}.IndexOf({args[1]})",
            StringOp.Equals when compMode != null => $"{args[0]}.Equals({args[1]}, {compMode})",
            StringOp.Equals => $"{args[0]}.Equals({args[1]})",

            // Instance methods - Transform operations
            StringOp.Substring => $"{args[0]}.Substring({args[1]}, {args[2]})",
            StringOp.SubstringFrom => $"{args[0]}.Substring({args[1]})",
            StringOp.Replace => $"{args[0]}.Replace({args[1]}, {args[2]})",
            StringOp.ToUpper => $"{args[0]}.ToUpper()",
            StringOp.ToLower => $"{args[0]}.ToLower()",
            StringOp.Trim => $"{args[0]}.Trim()",
            StringOp.TrimStart => $"{args[0]}.TrimStart()",
            StringOp.TrimEnd => $"{args[0]}.TrimEnd()",
            StringOp.PadLeft when args.Count == 2 => $"{args[0]}.PadLeft({args[1]})",
            StringOp.PadLeft => $"{args[0]}.PadLeft({args[1]}, {args[2]})",
            StringOp.PadRight when args.Count == 2 => $"{args[0]}.PadRight({args[1]})",
            StringOp.PadRight => $"{args[0]}.PadRight({args[1]}, {args[2]})",
            StringOp.Split => $"{args[0]}.Split({args[1]})",
            StringOp.ToString => $"{args[0]}.ToString()",

            // Static methods
            StringOp.Join => $"string.Join({args[0]}, {args[1]})",
            StringOp.Format => $"string.Format({string.Join(", ", args)})",
            StringOp.Concat => $"string.Concat({string.Join(", ", args)})",
            StringOp.IsNullOrEmpty => $"string.IsNullOrEmpty({args[0]})",
            StringOp.IsNullOrWhiteSpace => $"string.IsNullOrWhiteSpace({args[0]})",

            // Regex operations
            StringOp.RegexTest => $"System.Text.RegularExpressions.Regex.IsMatch({args[0]}, {args[1]})",
            StringOp.RegexMatch => $"System.Text.RegularExpressions.Regex.Match({args[0]}, {args[1]})",
            StringOp.RegexReplace => $"System.Text.RegularExpressions.Regex.Replace({args[0]}, {args[1]}, {args[2]})",
            StringOp.RegexSplit => $"System.Text.RegularExpressions.Regex.Split({args[0]}, {args[1]})",

            _ => throw new NotSupportedException($"Unknown string operation: {node.Operation}")
        };
    }

    // Native Char Operations

    public string Visit(CharOperationNode node)
    {
        var args = node.Arguments.Select(a => a.Accept(this)).ToList();

        return node.Operation switch
        {
            // Literal
            CharOp.CharLiteral => EmitCharLiteral(args[0]),

            // Extraction
            CharOp.CharAt => $"{args[0]}[{args[1]}]",
            CharOp.CharCode => $"(int){args[0]}",
            CharOp.CharFromCode => $"(char){args[0]}",

            // Classification
            CharOp.IsLetter => $"char.IsLetter({args[0]})",
            CharOp.IsDigit => $"char.IsDigit({args[0]})",
            CharOp.IsWhiteSpace => $"char.IsWhiteSpace({args[0]})",
            CharOp.IsUpper => $"char.IsUpper({args[0]})",
            CharOp.IsLower => $"char.IsLower({args[0]})",

            // Transformation
            CharOp.ToUpperChar => $"char.ToUpper({args[0]})",
            CharOp.ToLowerChar => $"char.ToLower({args[0]})",

            _ => throw new NotSupportedException($"Unknown char operation: {node.Operation}")
        };
    }

    /// <summary>
    /// Emits a C# char literal from a string literal argument.
    /// Input is the emitted C# string (e.g., "\"Y\""), output is a char literal (e.g., "'Y'").
    /// Handles special characters that need different escaping in char vs string context.
    /// </summary>
    private static string EmitCharLiteral(string stringArg)
    {
        // Strip surrounding double quotes from the emitted string literal
        var inner = stringArg;
        if (inner.StartsWith('"') && inner.EndsWith('"'))
        {
            inner = inner[1..^1];
        }

        // Handle characters that need escaping in a char literal
        return inner switch
        {
            "'" => @"'\''",        // single quote needs escaping in char context
            "\\\\" => @"'\\'",     // already-escaped backslash stays as-is
            "\\n" => "'\\n'",      // newline
            "\\r" => "'\\r'",      // carriage return
            "\\t" => "'\\t'",      // tab
            "\\0" => "'\\0'",      // null
            _ => $"'{inner}'"      // normal character
        };
    }

    // Native Type Operations

    public string Visit(TypeOperationNode node)
    {
        var operand = node.Operand.Accept(this);
        var csharpType = MapTypeName(node.TargetType);
        return node.Operation switch
        {
            TypeOp.Cast => $"({csharpType}){operand}",
            TypeOp.Is => $"{operand} is {csharpType}",
            TypeOp.As => $"{operand} as {csharpType}",
            _ => throw new NotSupportedException($"Unknown type operation: {node.Operation}")
        };
    }

    // Native StringBuilder Operations

    public string Visit(StringBuilderOperationNode node)
    {
        var args = node.Arguments.Select(a => a.Accept(this)).ToList();

        return node.Operation switch
        {
            // Creation
            StringBuilderOp.New when args.Count == 0 => "new System.Text.StringBuilder()",
            StringBuilderOp.New => $"new System.Text.StringBuilder({args[0]})",

            // Modification
            StringBuilderOp.Append => $"{args[0]}.Append({args[1]})",
            StringBuilderOp.AppendLine => $"{args[0]}.AppendLine({args[1]})",
            StringBuilderOp.Insert => $"{args[0]}.Insert({args[1]}, {args[2]})",
            StringBuilderOp.Remove => $"{args[0]}.Remove({args[1]}, {args[2]})",
            StringBuilderOp.Clear => $"{args[0]}.Clear()",

            // Query
            StringBuilderOp.ToString => $"{args[0]}.ToString()",
            StringBuilderOp.Length => $"{args[0]}.Length",

            _ => throw new NotSupportedException($"Unknown StringBuilder operation: {node.Operation}")
        };
    }

    // Fallback nodes for unsupported C# constructs (from C# to Calor conversion)

    public string Visit(FallbackExpressionNode node)
    {
        // Emit the original C# code with a TODO comment
        return $"/* TODO: {node.FeatureName} */ {node.OriginalCSharp}";
    }

    public string Visit(ExpressionStatementNode node)
    {
        var expr = node.Expression.Accept(this);
        AppendLine($"{expr};");
        return "";
    }

    public string Visit(FallbackCommentNode node)
    {
        // Emit as a comment block
        var escapedCode = node.OriginalCSharp.Replace("*/", "* /");
        AppendLine($"/* TODO: Manual conversion needed [{node.FeatureName}]");
        AppendLine($"   C#: {escapedCode}");
        if (!string.IsNullOrEmpty(node.Suggestion))
        {
            AppendLine($"   Suggestion: {node.Suggestion}");
        }
        AppendLine("*/");
        return "";
    }

    /// <summary>
    /// Represents a single variable's finite range.
    /// </summary>
    private sealed class VariableRange
    {
        public string Name { get; }
        public string Start { get; }
        public string End { get; }

        public VariableRange(string name, string start, string end)
        {
            Name = name;
            Start = start;
            End = end;
        }
    }

    /// <summary>
    /// Represents a finite range extracted from a quantifier expression.
    /// Supports single or multiple bound variables.
    /// </summary>
    private sealed class FiniteRange
    {
        public string Start { get; }
        public string End { get; }
        public ExpressionNode Body { get; }
        public IReadOnlyList<VariableRange> AllRanges { get; }

        public FiniteRange(string start, string end, ExpressionNode body)
            : this(start, end, body, Array.Empty<VariableRange>())
        {
        }

        public FiniteRange(string start, string end, ExpressionNode body, IReadOnlyList<VariableRange> allRanges)
        {
            Start = start;
            End = end;
            Body = body;
            AllRanges = allRanges;
        }
    }

    /// <summary>
    /// Attempts to extract finite ranges from a forall expression.
    /// Supports single and multiple bound variables.
    /// Pattern: (forall ((i type)) (-> (&& (>= i start) (< i end)) body))
    /// Pattern: (forall ((i type) (j type)) (-> (&& (>= i 0) (< i n) (>= j 0) (< j m)) body))
    /// </summary>
    private FiniteRange? TryExtractFiniteRange(ForallExpressionNode node)
    {
        // Must have at least one bound variable
        if (node.BoundVariables.Count == 0)
            return null;

        // Body should be an implication
        if (node.Body is not ImplicationExpressionNode impl)
            return null;

        // Try to extract bounds for all bound variables
        var allRanges = new List<VariableRange>();
        foreach (var boundVar in node.BoundVariables)
        {
            if (!TryExtractBounds(impl.Antecedent, boundVar.Name, out var start, out var end))
                return null;
            allRanges.Add(new VariableRange(boundVar.Name, start, end));
        }

        // Use the first variable's range for backward compatibility
        var firstRange = allRanges[0];
        return new FiniteRange(firstRange.Start, firstRange.End, impl.Consequent, allRanges);
    }

    /// <summary>
    /// Attempts to extract a finite range from an exists expression.
    /// Pattern: (exists ((i type)) (&& (>= i start) (< i end) body))
    /// Pattern: (exists ((i type) (j type)) (&& (>= i 0) (< i n) (>= j 0) (< j m) body))
    /// </summary>
    private FiniteRange? TryExtractFiniteRangeForExists(ExistsExpressionNode node)
    {
        // Must have at least one bound variable
        if (node.BoundVariables.Count == 0)
            return null;

        // Collect all conjuncts from the body
        var conjuncts = new List<ExpressionNode>();
        FlattenConjunction(node.Body, conjuncts);

        // Try to extract bounds for all bound variables
        var allRanges = new List<VariableRange>();
        var boundVarNames = node.BoundVariables.Select(bv => bv.Name).ToHashSet(StringComparer.Ordinal);

        foreach (var boundVar in node.BoundVariables)
        {
            string? lower = null;
            string? upper = null;

            foreach (var conjunct in conjuncts)
            {
                if (conjunct is BinaryOperationNode cmp && cmp.Operator != BinaryOperator.And)
                {
                    ExtractBound(cmp, boundVar.Name, ref lower, ref upper);
                }
            }

            if (lower == null || upper == null)
                return null;

            allRanges.Add(new VariableRange(boundVar.Name, lower, upper));
        }

        // Find the body expression (conjuncts that aren't bound constraints)
        ExpressionNode? bodyExpr = null;
        foreach (var conjunct in conjuncts)
        {
            if (conjunct is BinaryOperationNode cmp && cmp.Operator != BinaryOperator.And)
            {
                // Check if this conjunct is a bound constraint for any variable
                bool isBoundConstraint = false;
                foreach (var boundVar in node.BoundVariables)
                {
                    string? testLower = null;
                    string? testUpper = null;
                    ExtractBound(cmp, boundVar.Name, ref testLower, ref testUpper);
                    if (testLower != null || testUpper != null)
                    {
                        isBoundConstraint = true;
                        break;
                    }
                }

                if (!isBoundConstraint)
                {
                    bodyExpr = conjunct;
                    break;
                }
            }
            else if (conjunct is not BinaryOperationNode)
            {
                bodyExpr = conjunct;
                break;
            }
        }

        if (bodyExpr == null)
            return null;

        var firstRange = allRanges[0];
        return new FiniteRange(firstRange.Start, firstRange.End, bodyExpr, allRanges);
    }

    /// <summary>
    /// Tries to extract bounds from a conjunction like (&& (>= i 0) (< i n))
    /// Handles arbitrarily nested ANDs.
    /// </summary>
    private bool TryExtractBounds(ExpressionNode expr, string varName, out string start, out string end)
    {
        start = "0";
        end = "0";

        string? lowerBound = null;
        string? upperBound = null;

        // Recursively collect all bound expressions from the conjunction
        ExtractBoundsRecursive(expr, varName, ref lowerBound, ref upperBound);

        if (lowerBound != null && upperBound != null)
        {
            start = lowerBound;
            end = upperBound;
            return true;
        }

        return false;
    }

    /// <summary>
    /// Recursively extracts bounds from nested AND expressions.
    /// </summary>
    private void ExtractBoundsRecursive(ExpressionNode expr, string varName, ref string? lowerBound, ref string? upperBound)
    {
        if (expr is BinaryOperationNode binOp)
        {
            if (binOp.Operator == BinaryOperator.And)
            {
                // Recursively process both sides of AND
                ExtractBoundsRecursive(binOp.Left, varName, ref lowerBound, ref upperBound);
                ExtractBoundsRecursive(binOp.Right, varName, ref lowerBound, ref upperBound);
            }
            else
            {
                // Try to extract a bound from this comparison
                ExtractBound(binOp, varName, ref lowerBound, ref upperBound);
            }
        }
    }

    /// <summary>
    /// Tries to extract a single bound from a comparison expression like (>= i 0) or (< i n)
    /// </summary>
    private void ExtractBound(BinaryOperationNode cmp, string varName, ref string? lowerBound, ref string? upperBound)
    {
        // Check if one operand is the variable
        bool isVarLeft = cmp.Left is ReferenceNode leftRef && leftRef.Name == varName;
        bool isVarRight = cmp.Right is ReferenceNode rightRef && rightRef.Name == varName;

        if (!isVarLeft && !isVarRight)
            return;

        var otherOperand = isVarLeft ? cmp.Right : cmp.Left;
        var otherStr = otherOperand.Accept(this);

        // Determine bound type based on operator and variable position
        switch (cmp.Operator)
        {
            case BinaryOperator.GreaterOrEqual when isVarLeft:
            case BinaryOperator.LessOrEqual when isVarRight:
                // i >= start => lower bound
                lowerBound ??= otherStr;
                break;
            case BinaryOperator.GreaterThan when isVarLeft:
            case BinaryOperator.LessThan when isVarRight:
                // i > start => lower bound is start + 1
                lowerBound ??= $"({otherStr} + 1)";
                break;
            case BinaryOperator.LessThan when isVarLeft:
            case BinaryOperator.GreaterThan when isVarRight:
                // i < end => upper bound
                upperBound ??= otherStr;
                break;
            case BinaryOperator.LessOrEqual when isVarLeft:
            case BinaryOperator.GreaterOrEqual when isVarRight:
                // i <= end => upper bound is end + 1
                upperBound ??= $"({otherStr} + 1)";
                break;
        }
    }

    /// <summary>
    /// Tries to extract bounds and body from an exists conjunction like (&& (&& (>= i 0) (< i n)) body)
    /// The body is the rightmost non-bound expression in the conjunction.
    /// </summary>
    private bool TryExtractBoundsAndBody(ExpressionNode expr, string varName, out string start, out string end, out ExpressionNode? body)
    {
        start = "0";
        end = "0";
        body = null;

        // Collect all conjuncts
        var conjuncts = new List<ExpressionNode>();
        FlattenConjunction(expr, conjuncts);

        if (conjuncts.Count < 3) // Need at least lower bound, upper bound, and body
            return false;

        string? lowerBound = null;
        string? upperBound = null;
        ExpressionNode? bodyExpr = null;

        // Try to extract bounds from each conjunct
        foreach (var conjunct in conjuncts)
        {
            if (conjunct is BinaryOperationNode cmp && cmp.Operator != BinaryOperator.And)
            {
                var prevLower = lowerBound;
                var prevUpper = upperBound;
                ExtractBound(cmp, varName, ref lowerBound, ref upperBound);

                // If this conjunct didn't contribute a new bound, it's the body
                if (prevLower == lowerBound && prevUpper == upperBound)
                {
                    bodyExpr = conjunct;
                }
            }
            else if (conjunct is not BinaryOperationNode)
            {
                // Non-binary expression - this is the body
                bodyExpr = conjunct;
            }
        }

        if (lowerBound != null && upperBound != null && bodyExpr != null)
        {
            start = lowerBound;
            end = upperBound;
            body = bodyExpr;
            return true;
        }

        return false;
    }

    /// <summary>
    /// Flattens nested AND expressions into a list of conjuncts.
    /// </summary>
    private void FlattenConjunction(ExpressionNode expr, List<ExpressionNode> conjuncts)
    {
        if (expr is BinaryOperationNode binOp && binOp.Operator == BinaryOperator.And)
        {
            FlattenConjunction(binOp.Left, conjuncts);
            FlattenConjunction(binOp.Right, conjuncts);
        }
        else
        {
            conjuncts.Add(expr);
        }
    }
}

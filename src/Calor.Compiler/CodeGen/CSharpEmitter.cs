using System.Text;
using Calor.Compiler.Ast;
using Calor.Compiler.Migration;
using Calor.Compiler.Verification.Z3;

// Import ContractMode from Program.cs
using ContractMode = Calor.Compiler.ContractMode;

namespace Calor.Compiler.CodeGen;

/// <summary>
/// Contract enforcement mode for code generation.
/// </summary>
public enum EmitContractMode
{
    /// <summary>
    /// No contract checks emitted.
    /// </summary>
    Off,

    /// <summary>
    /// Full contract checks with detailed messages.
    /// </summary>
    Debug,

    /// <summary>
    /// Lean contract checks with minimal messages.
    /// </summary>
    Release
}

/// <summary>
/// Emits C# source code from an Calor AST.
/// </summary>
public sealed class CSharpEmitter : IAstVisitor<string>
{
    private readonly StringBuilder _builder = new();
    private int _indentLevel;
    private string? _currentClassName;
    private string? _currentFunctionId;
    private string? _currentFilePath;
    private readonly EmitContractMode _contractMode;
    private readonly ModuleVerificationResult? _verificationResults;

    // Track current indices for contract emission
    private int _currentPreconditionIndex;
    private int _currentPostconditionIndex;

    public CSharpEmitter() : this(EmitContractMode.Debug)
    {
    }

    public CSharpEmitter(ContractMode contractMode) : this(contractMode, null)
    {
    }

    public CSharpEmitter(ContractMode contractMode, ModuleVerificationResult? verificationResults)
    {
        _contractMode = contractMode switch
        {
            ContractMode.Off => EmitContractMode.Off,
            ContractMode.Release => EmitContractMode.Release,
            _ => EmitContractMode.Debug
        };
        _verificationResults = verificationResults;
    }

    public CSharpEmitter(EmitContractMode contractMode)
    {
        _contractMode = contractMode;
    }

    public string Emit(ModuleNode module, string? filePath = null)
    {
        _builder.Clear();
        _indentLevel = 0;
        _currentFilePath = filePath;

        var result = Visit(module);
        return result;
    }

    public string Emit(ModuleNode module)
    {
        return Emit(module, null);
    }

    private void AppendLine(string line = "")
    {
        if (string.IsNullOrEmpty(line))
        {
            _builder.AppendLine();
        }
        else
        {
            _builder.Append(new string(' ', _indentLevel * 4));
            _builder.AppendLine(line);
        }
    }

    private void Indent() => _indentLevel++;
    private void Dedent() => _indentLevel--;

    public string Visit(ModuleNode node)
    {
        AppendLine("// <auto-generated>");
        AppendLine("// This code was generated by the Calor compiler.");
        AppendLine("// Do not modify this file directly.");
        AppendLine("// </auto-generated>");
        AppendLine();

        // Always include System and Calor.Runtime
        var emittedUsings = new HashSet<string>(StringComparer.Ordinal) { "System", "Calor.Runtime" };
        AppendLine("using System;");
        AppendLine("using Calor.Runtime;");

        // Emit user-defined using directives
        foreach (var usingDirective in node.Usings)
        {
            var usingCode = Visit(usingDirective);
            if (!string.IsNullOrEmpty(usingCode))
            {
                // Track to avoid duplicates
                if (!emittedUsings.Contains(usingDirective.Namespace))
                {
                    AppendLine(usingCode);
                    emittedUsings.Add(usingDirective.Namespace);
                }
            }
        }
        AppendLine();

        var namespaceName = SanitizeIdentifier(node.Name);

        // Emit module-level extended metadata as file-level comments
        if (node.Context != null)
        {
            var contextComment = Visit(node.Context);
            foreach (var line in contextComment.Split('\n'))
            {
                AppendLine(line);
            }
            AppendLine();
        }
        foreach (var decision in node.Decisions)
        {
            var decisionComment = Visit(decision);
            foreach (var line in decisionComment.Split('\n'))
            {
                AppendLine(line);
            }
            AppendLine();
        }

        AppendLine($"namespace {namespaceName}");
        AppendLine("{");
        Indent();

        // Emit module-level issues as comments
        foreach (var issue in node.Issues)
        {
            AppendLine(Visit(issue));
        }
        // Emit module-level assumptions
        foreach (var assume in node.Assumptions)
        {
            AppendLine(Visit(assume));
        }
        // Emit module-level invariants as comments
        foreach (var invariant in node.Invariants)
        {
            var invCode = Visit(invariant);
            AppendLine($"// INVARIANT: {invCode}");
        }
        if (node.Issues.Count > 0 || node.Assumptions.Count > 0 || node.Invariants.Count > 0)
        {
            AppendLine();
        }

        // Emit interfaces
        foreach (var iface in node.Interfaces)
        {
            Visit(iface);
            AppendLine();
        }

        // Emit enums
        foreach (var enumDef in node.Enums)
        {
            Visit(enumDef);
            AppendLine();
        }

        // Emit delegates
        foreach (var del in node.Delegates)
        {
            Visit(del);
            AppendLine();
        }

        // Emit classes
        foreach (var cls in node.Classes)
        {
            Visit(cls);
            AppendLine();
        }

        // Emit module-level functions in a static class
        if (node.Functions.Count > 0)
        {
            AppendLine($"public static class {namespaceName}Module");
            AppendLine("{");
            Indent();

            foreach (var function in node.Functions)
            {
                Visit(function);
                AppendLine();
            }

            Dedent();
            AppendLine("}");
        }

        Dedent();
        AppendLine("}");

        return _builder.ToString();
    }

    public string Visit(UsingDirectiveNode node)
    {
        if (node.IsStatic)
        {
            return $"using static {node.Namespace};";
        }
        else if (node.Alias != null)
        {
            return $"using {node.Alias} = {node.Namespace};";
        }
        else
        {
            return $"using {node.Namespace};";
        }
    }

    public string Visit(FunctionNode node)
    {
        // Track current function ID for contract emission
        _currentFunctionId = node.Id;

        // Reset contract indices for this function
        _currentPreconditionIndex = 0;
        _currentPostconditionIndex = 0;

        // Emit extended metadata as documentation comments
        foreach (var issue in node.Issues)
        {
            AppendLine(Visit(issue));
        }
        if (node.Uses != null)
        {
            AppendLine(Visit(node.Uses));
        }
        if (node.UsedBy != null)
        {
            AppendLine(Visit(node.UsedBy));
        }
        foreach (var assume in node.Assumptions)
        {
            AppendLine(Visit(assume));
        }
        if (node.Complexity != null)
        {
            AppendLine(Visit(node.Complexity));
        }
        if (node.Since != null)
        {
            AppendLine(Visit(node.Since));
        }
        foreach (var breaking in node.BreakingChanges)
        {
            AppendLine(Visit(breaking));
        }
        foreach (var prop in node.Properties)
        {
            AppendLine(Visit(prop));
        }
        if (node.Lock != null)
        {
            AppendLine(Visit(node.Lock));
        }
        if (node.Author != null)
        {
            AppendLine(Visit(node.Author));
        }
        if (node.TaskRef != null)
        {
            AppendLine(Visit(node.TaskRef));
        }

        // Emit [Obsolete] attribute if deprecated
        if (node.Deprecated != null)
        {
            AppendLine(Visit(node.Deprecated));
        }

        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "private"
        };

        var returnType = node.Output?.TypeName ?? "void";
        var mappedReturnType = MapTypeName(returnType);
        var hasReturnValue = returnType.ToUpperInvariant() != "VOID";

        var parameters = string.Join(", ", node.Parameters.Select(p =>
            $"{MapTypeName(p.TypeName)} {SanitizeIdentifier(p.Name)}"));

        var methodName = SanitizeIdentifier(node.Name);

        // Build type parameters if present
        var typeParams = "";
        var whereClause = "";
        if (node.TypeParameters.Count > 0)
        {
            typeParams = "<" + string.Join(", ", node.TypeParameters.Select(tp => tp.Name)) + ">";

            // Build where clauses
            var whereClauses = new List<string>();
            foreach (var tp in node.TypeParameters)
            {
                if (tp.Constraints.Count > 0)
                {
                    var constraints = string.Join(", ", tp.Constraints.Select(c => EmitConstraint(c)));
                    whereClauses.Add($"where {tp.Name} : {constraints}");
                }
            }
            if (whereClauses.Count > 0)
            {
                whereClause = " " + string.Join(" ", whereClauses);
            }
        }

        // Check if this is the entry point
        var isMain = node.Name.Equals("Main", StringComparison.OrdinalIgnoreCase);
        var staticKeyword = "static "; // All module functions are static

        AppendLine($"{visibility} {staticKeyword}{mappedReturnType} {methodName}{typeParams}({parameters}){whereClause}");
        AppendLine("{");
        Indent();

        // Emit inline examples as Debug.Assert
        foreach (var example in node.Examples)
        {
            AppendLine(Visit(example));
        }

        // Emit preconditions (REQUIRES)
        foreach (var requires in node.Preconditions)
        {
            var check = Visit(requires);
            AppendLine(check);
        }

        // If we have postconditions and a return value, we need special handling
        if (node.Postconditions.Count > 0 && hasReturnValue)
        {
            AppendLine($"{mappedReturnType} __result__ = default;");
            AppendLine();

            // Emit body statements, transforming return statements
            foreach (var statement in node.Body)
            {
                if (statement is ReturnStatementNode returnStmt && returnStmt.Expression != null)
                {
                    var expr = returnStmt.Expression.Accept(this);
                    AppendLine($"__result__ = {expr};");
                }
                else
                {
                    var stmtCode = statement.Accept(this);
                    AppendLine(stmtCode);
                }
            }

            AppendLine();
            // Emit postconditions (ENSURES)
            foreach (var ensures in node.Postconditions)
            {
                // Replace 'result' references with '__result__'
                var check = Visit(ensures).Replace("result", "__result__");
                AppendLine(check);
            }

            AppendLine("return __result__;");
        }
        else
        {
            // No postconditions or void return - emit body normally
            foreach (var statement in node.Body)
            {
                var stmtCode = statement.Accept(this);
                AppendLine(stmtCode);
            }

            // Emit postconditions for void functions (they can't reference 'result')
            foreach (var ensures in node.Postconditions)
            {
                var check = Visit(ensures);
                AppendLine(check);
            }
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(ParameterNode node)
    {
        return $"{MapTypeName(node.TypeName)} {SanitizeIdentifier(node.Name)}";
    }

    public string Visit(CallStatementNode node)
    {
        var target = node.Target;
        var args = string.Join(", ", node.Arguments.Select(a => a.Accept(this)));

        return $"{target}({args});";
    }

    public string Visit(ReturnStatementNode node)
    {
        if (node.Expression == null)
        {
            return "return;";
        }

        var expr = node.Expression.Accept(this);
        return $"return {expr};";
    }

    public string Visit(IntLiteralNode node)
    {
        return node.Value.ToString();
    }

    public string Visit(StringLiteralNode node)
    {
        // Check if this is an interpolated string (contains ${...})
        if (node.Value.Contains("${"))
        {
            // Convert Calor interpolation ${expr} to C# interpolation {expr}
            var converted = System.Text.RegularExpressions.Regex.Replace(
                node.Value,
                @"\$\{([^}]+)\}",
                "{$1}");

            // Escape for C# string literal (but not the interpolation braces)
            var escaped = converted
                .Replace("\\", "\\\\")
                .Replace("\"", "\\\"")
                .Replace("\n", "\\n")
                .Replace("\r", "\\r")
                .Replace("\t", "\\t");

            return $"$\"{escaped}\"";
        }

        // Escape the string for C#
        var escapedValue = node.Value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");

        return $"\"{escapedValue}\"";
    }

    public string Visit(BoolLiteralNode node)
    {
        return node.Value ? "true" : "false";
    }

    public string Visit(ConditionalExpressionNode node)
    {
        var condition = node.Condition.Accept(this);
        var whenTrue = node.WhenTrue.Accept(this);
        var whenFalse = node.WhenFalse.Accept(this);
        return $"({condition} ? {whenTrue} : {whenFalse})";
    }

    public string Visit(FloatLiteralNode node)
    {
        return node.Value.ToString(System.Globalization.CultureInfo.InvariantCulture);
    }

    public string Visit(ReferenceNode node)
    {
        // Handle 'is' pattern expressions like "other is UnitSystem otherUnitSystem"
        // These should be emitted as-is without sanitization
        if (node.Name.Contains(" is "))
        {
            return node.Name;
        }

        // Handle C# keywords that are used as literals (not identifiers)
        if (node.Name is "null" or "true" or "false")
        {
            return node.Name;
        }

        // Handle member access like "args.Length" - preserve the dot notation
        if (node.Name.Contains('.'))
        {
            var parts = node.Name.Split('.');
            var sanitizedParts = parts.Select(SanitizeIdentifier);
            return string.Join(".", sanitizedParts);
        }
        return SanitizeIdentifier(node.Name);
    }

    // Phase 2: Control Flow

    public string Visit(ForStatementNode node)
    {
        var varName = SanitizeIdentifier(node.VariableName);
        var from = node.From.Accept(this);
        var to = node.To.Accept(this);
        var step = node.Step?.Accept(this) ?? "1";

        // Determine loop direction based on step (simple heuristic)
        var isPositiveStep = !step.StartsWith("-");
        var comparison = isPositiveStep ? "<=" : ">=";
        var increment = step == "1" ? $"{varName}++" : $"{varName} += {step}";

        AppendLine($"for (var {varName} = {from}; {varName} {comparison} {to}; {increment})");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            var stmtCode = stmt.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(WhileStatementNode node)
    {
        var condition = node.Condition.Accept(this);

        AppendLine($"while ({condition})");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            var stmtCode = stmt.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(DoWhileStatementNode node)
    {
        var condition = node.Condition.Accept(this);

        AppendLine("do");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            var stmtCode = stmt.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine($"}} while ({condition});");

        return "";
    }

    public string Visit(IfStatementNode node)
    {
        var condition = node.Condition.Accept(this);

        AppendLine($"if ({condition})");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.ThenBody)
        {
            var stmtCode = stmt.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine("}");

        // Emit ELSEIF clauses
        foreach (var elseIf in node.ElseIfClauses)
        {
            var elseIfCondition = elseIf.Condition.Accept(this);
            AppendLine($"else if ({elseIfCondition})");
            AppendLine("{");
            Indent();

            foreach (var stmt in elseIf.Body)
            {
                var stmtCode = stmt.Accept(this);
                AppendLine(stmtCode);
            }

            Dedent();
            AppendLine("}");
        }

        // Emit ELSE clause
        if (node.ElseBody != null)
        {
            AppendLine("else");
            AppendLine("{");
            Indent();

            foreach (var stmt in node.ElseBody)
            {
                var stmtCode = stmt.Accept(this);
                AppendLine(stmtCode);
            }

            Dedent();
            AppendLine("}");
        }

        return "";
    }

    public string Visit(BindStatementNode node)
    {
        var varName = SanitizeIdentifier(node.Name);
        var typeName = node.TypeName != null ? MapTypeName(node.TypeName) : "var";

        if (node.Initializer != null)
        {
            var initExpr = node.Initializer.Accept(this);
            return $"{typeName} {varName} = {initExpr};";
        }

        // No initializer - need explicit type
        if (node.TypeName == null)
        {
            typeName = "int"; // Default to int
        }
        return $"{typeName} {varName} = default;";
    }

    public string Visit(BinaryOperationNode node)
    {
        var left = node.Left.Accept(this);
        var right = node.Right.Accept(this);

        // Special handling for Power operator (use Math.Pow)
        if (node.Operator == BinaryOperator.Power)
        {
            return $"Math.Pow({left}, {right})";
        }

        var op = node.Operator.ToCSharpOperator();
        return $"({left} {op} {right})";
    }

    public string Visit(UnaryOperationNode node)
    {
        var operand = node.Operand.Accept(this);
        var op = node.Operator.ToCSharpOperator();
        return $"({op}{operand})";
    }

    public string Visit(PrintStatementNode node)
    {
        var expr = node.Expression.Accept(this);
        var method = node.IsWriteLine ? "Console.WriteLine" : "Console.Write";
        return $"{method}({expr});";
    }

    public string Visit(ContinueStatementNode node)
    {
        return "continue;";
    }

    public string Visit(BreakStatementNode node)
    {
        return "break;";
    }

    // Phase 3: Type System

    public string Visit(RecordDefinitionNode node)
    {
        AppendLine($"public record {SanitizeIdentifier(node.Name)}(");
        Indent();

        for (int i = 0; i < node.Fields.Count; i++)
        {
            var field = node.Fields[i];
            var typeName = MapTypeName(field.TypeName);
            var fieldName = SanitizeIdentifier(field.Name);
            var comma = i < node.Fields.Count - 1 ? "," : "";
            AppendLine($"{typeName} {fieldName}{comma}");
        }

        Dedent();
        AppendLine(");");

        return "";
    }

    public string Visit(UnionTypeDefinitionNode node)
    {
        // Generate as abstract base class with derived classes for each variant
        var typeName = SanitizeIdentifier(node.Name);

        AppendLine($"public abstract record {typeName};");
        AppendLine();

        foreach (var variant in node.Variants)
        {
            var variantName = SanitizeIdentifier(variant.Name);
            if (variant.Fields.Count == 0)
            {
                AppendLine($"public sealed record {variantName}() : {typeName};");
            }
            else
            {
                var fields = string.Join(", ", variant.Fields.Select(f =>
                    $"{MapTypeName(f.TypeName)} {SanitizeIdentifier(f.Name)}"));
                AppendLine($"public sealed record {variantName}({fields}) : {typeName};");
            }
        }

        return "";
    }

    public string Visit(EnumDefinitionNode node)
    {
        // Generate C# enum with optional underlying type
        var typeName = SanitizeIdentifier(node.Name);
        var baseType = node.UnderlyingType != null
            ? $" : {MapTypeName(node.UnderlyingType)}"
            : "";

        AppendLine($"public enum {typeName}{baseType}");
        AppendLine("{");
        Indent();

        foreach (var member in node.Members)
        {
            Visit(member);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(EnumMemberNode node)
    {
        var memberName = SanitizeIdentifier(node.Name);
        var value = node.Value != null ? $" = {node.Value}" : "";
        AppendLine($"{memberName}{value},");
        return "";
    }

    public string Visit(RecordCreationNode node)
    {
        var typeName = SanitizeIdentifier(node.TypeName);
        var fields = string.Join(", ", node.Fields.Select(f => f.Value.Accept(this)));
        return $"new {typeName}({fields})";
    }

    public string Visit(FieldAccessNode node)
    {
        var target = node.Target.Accept(this);
        var fieldName = SanitizeIdentifier(node.FieldName);
        return $"{target}.{fieldName}";
    }

    public string Visit(SomeExpressionNode node)
    {
        var value = node.Value.Accept(this);
        return $"Calor.Runtime.Option.Some({value})";
    }

    public string Visit(NoneExpressionNode node)
    {
        if (node.TypeName != null)
        {
            var typeName = MapTypeName(node.TypeName);
            return $"Calor.Runtime.Option<{typeName}>.None()";
        }
        return "Calor.Runtime.Option.None<object>()";
    }

    public string Visit(OkExpressionNode node)
    {
        var value = node.Value.Accept(this);
        return $"Calor.Runtime.Result.Ok<{GetInferredTypeName(node.Value)}, string>({value})";
    }

    public string Visit(ErrExpressionNode node)
    {
        var error = node.Error.Accept(this);
        return $"Calor.Runtime.Result.Err<object, {GetInferredTypeName(node.Error)}>({error})";
    }

    public string Visit(MatchExpressionNode node)
    {
        // Generate as switch expression
        var target = node.Target.Accept(this);
        var sb = new System.Text.StringBuilder();
        sb.Append($"{target} switch {{ ");

        for (int i = 0; i < node.Cases.Count; i++)
        {
            var matchCase = node.Cases[i];
            var pattern = EmitPattern(matchCase.Pattern);

            // Emit guard clause if present
            var guard = matchCase.Guard != null ? $" when {matchCase.Guard.Accept(this)}" : "";

            // For expression match, the body should yield a value
            // Take the last statement if it's a return, otherwise default
            var body = "default";
            if (matchCase.Body.Count > 0)
            {
                var lastStmt = matchCase.Body[^1];
                if (lastStmt is ReturnStatementNode ret && ret.Expression != null)
                {
                    body = ret.Expression.Accept(this);
                }
            }
            sb.Append($"{pattern}{guard} => {body}");
            if (i < node.Cases.Count - 1) sb.Append(", ");
        }

        sb.Append(" }");
        return sb.ToString();
    }

    public string Visit(MatchStatementNode node)
    {
        var target = node.Target.Accept(this);

        AppendLine($"switch ({target})");
        AppendLine("{");
        Indent();

        foreach (var matchCase in node.Cases)
        {
            var pattern = EmitPattern(matchCase.Pattern);
            AppendLine($"case {pattern}:");
            Indent();

            foreach (var stmt in matchCase.Body)
            {
                var stmtCode = stmt.Accept(this);
                AppendLine(stmtCode);
            }

            AppendLine("break;");
            Dedent();
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    private string EmitPattern(PatternNode pattern)
    {
        return pattern switch
        {
            WildcardPatternNode => "_",
            VariablePatternNode vp => $"var {SanitizeIdentifier(vp.Name)}",
            VarPatternNode varP => $"var {SanitizeIdentifier(varP.Name)}",
            LiteralPatternNode lp => lp.Literal.Accept(this),
            RelationalPatternNode rp => Visit(rp),
            PropertyPatternNode pp => Visit(pp),
            PositionalPatternNode pos => Visit(pos),
            ConstantPatternNode cp => cp.Value.Accept(this),
            SomePatternNode sp => $"{{ IsSome: true, Value: {EmitPattern(sp.InnerPattern)} }}",
            NonePatternNode => "{ IsNone: true }",
            OkPatternNode op => $"{{ IsOk: true, Value: {EmitPattern(op.InnerPattern)} }}",
            ErrPatternNode ep => $"{{ IsErr: true, Error: {EmitPattern(ep.InnerPattern)} }}",
            ListPatternNode lp => Visit(lp),
            _ => "_"
        };
    }

    public string Visit(MatchCaseNode node)
    {
        var pattern = EmitPattern(node.Pattern);
        // For match statement context, case is emitted as part of switch
        return pattern;
    }

    public string Visit(WildcardPatternNode node) => "_";

    public string Visit(VariablePatternNode node) => $"var {SanitizeIdentifier(node.Name)}";

    public string Visit(LiteralPatternNode node) => node.Literal.Accept(this);

    public string Visit(SomePatternNode node)
        => $"{{ IsSome: true, Value: {node.InnerPattern.Accept(this)} }}";

    public string Visit(NonePatternNode node) => "{ IsNone: true }";

    public string Visit(OkPatternNode node)
        => $"{{ IsOk: true, Value: {node.InnerPattern.Accept(this)} }}";

    public string Visit(ErrPatternNode node)
        => $"{{ IsErr: true, Error: {node.InnerPattern.Accept(this)} }}";

    // Phase 4: Contracts

    public string Visit(RequiresNode node)
    {
        // Off mode: no contract checks
        if (_contractMode == EmitContractMode.Off)
        {
            _currentPreconditionIndex++;
            return ""; // No check emitted
        }

        var condition = node.Condition.Accept(this);
        var functionId = _currentFunctionId ?? "unknown";

        // Check verification status if available
        var verificationStatus = GetPreconditionVerificationStatus();
        _currentPreconditionIndex++;

        // Proven preconditions: emit comment instead of runtime check
        if (verificationStatus == ContractVerificationStatus.Proven)
        {
            return $"// PROVEN: Precondition always satisfiable: {condition}";
        }

        // Release mode: lean exception
        if (_contractMode == EmitContractMode.Release)
        {
            return $"if (!({condition})) throw new Calor.Runtime.ContractViolationException(\"{EscapeString(functionId)}\", Calor.Runtime.ContractKind.Requires);";
        }

        // Debug mode: full details
        var message = node.Message != null
            ? EscapeString(node.Message)
            : $"Precondition failed: {EscapeString(condition)}";
        var sourceFile = _currentFilePath != null ? $"\"{EscapeString(_currentFilePath)}\"" : "null";

        return $"if (!({condition})) throw new Calor.Runtime.ContractViolationException(" +
               $"\"{message}\", " +
               $"\"{EscapeString(functionId)}\", " +
               $"Calor.Runtime.ContractKind.Requires, " +
               $"startOffset: {node.Span.Start}, " +
               $"length: {node.Span.Length}, " +
               $"sourceFile: {sourceFile}, " +
               $"line: {node.Span.Line}, " +
               $"column: {node.Span.Column}, " +
               $"condition: \"{EscapeString(condition)}\");";
    }

    public string Visit(EnsuresNode node)
    {
        // Off mode: no contract checks
        if (_contractMode == EmitContractMode.Off)
        {
            _currentPostconditionIndex++;
            return ""; // No check emitted
        }

        var condition = node.Condition.Accept(this);
        var functionId = _currentFunctionId ?? "unknown";

        // Check verification status if available
        var verificationStatus = GetPostconditionVerificationStatus();
        _currentPostconditionIndex++;

        // Proven postconditions: emit comment instead of runtime check
        if (verificationStatus == ContractVerificationStatus.Proven)
        {
            return $"// PROVEN: Postcondition statically verified: {condition}";
        }

        // Release mode: lean exception
        if (_contractMode == EmitContractMode.Release)
        {
            return $"if (!({condition})) throw new Calor.Runtime.ContractViolationException(\"{EscapeString(functionId)}\", Calor.Runtime.ContractKind.Ensures);";
        }

        // Debug mode: full details
        var message = node.Message != null
            ? EscapeString(node.Message)
            : $"Postcondition failed: {EscapeString(condition)}";
        var sourceFile = _currentFilePath != null ? $"\"{EscapeString(_currentFilePath)}\"" : "null";

        return $"if (!({condition})) throw new Calor.Runtime.ContractViolationException(" +
               $"\"{message}\", " +
               $"\"{EscapeString(functionId)}\", " +
               $"Calor.Runtime.ContractKind.Ensures, " +
               $"startOffset: {node.Span.Start}, " +
               $"length: {node.Span.Length}, " +
               $"sourceFile: {sourceFile}, " +
               $"line: {node.Span.Line}, " +
               $"column: {node.Span.Column}, " +
               $"condition: \"{EscapeString(condition)}\");";
    }

    public string Visit(InvariantNode node)
    {
        // Off mode: no contract checks
        if (_contractMode == EmitContractMode.Off)
        {
            return ""; // No check emitted
        }

        var condition = node.Condition.Accept(this);
        var functionId = _currentFunctionId ?? "unknown";

        // Release mode: lean exception
        if (_contractMode == EmitContractMode.Release)
        {
            return $"if (!({condition})) throw new Calor.Runtime.ContractViolationException(\"{EscapeString(functionId)}\", Calor.Runtime.ContractKind.Invariant);";
        }

        // Debug mode: full details
        var message = node.Message != null
            ? EscapeString(node.Message)
            : $"Invariant violated: {EscapeString(condition)}";
        var sourceFile = _currentFilePath != null ? $"\"{EscapeString(_currentFilePath)}\"" : "null";

        return $"if (!({condition})) throw new Calor.Runtime.ContractViolationException(" +
               $"\"{message}\", " +
               $"\"{EscapeString(functionId)}\", " +
               $"Calor.Runtime.ContractKind.Invariant, " +
               $"startOffset: {node.Span.Start}, " +
               $"length: {node.Span.Length}, " +
               $"sourceFile: {sourceFile}, " +
               $"line: {node.Span.Line}, " +
               $"column: {node.Span.Column}, " +
               $"condition: \"{EscapeString(condition)}\");";
    }

    private static string EscapeString(string s)
    {
        return s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "\\r");
    }

    private ContractVerificationStatus? GetPreconditionVerificationStatus()
    {
        if (_verificationResults == null || _currentFunctionId == null)
            return null;

        var funcResult = _verificationResults.GetFunctionResult(_currentFunctionId);
        if (funcResult == null || _currentPreconditionIndex >= funcResult.PreconditionResults.Count)
            return null;

        return funcResult.PreconditionResults[_currentPreconditionIndex].Status;
    }

    private ContractVerificationStatus? GetPostconditionVerificationStatus()
    {
        if (_verificationResults == null || _currentFunctionId == null)
            return null;

        var funcResult = _verificationResults.GetFunctionResult(_currentFunctionId);
        if (funcResult == null || _currentPostconditionIndex >= funcResult.PostconditionResults.Count)
            return null;

        return funcResult.PostconditionResults[_currentPostconditionIndex].Status;
    }

    // Phase 6: Arrays and Collections

    public string Visit(ArrayCreationNode node)
    {
        var elementType = MapTypeName(node.ElementType);
        var varName = SanitizeIdentifier(node.Name);

        if (node.Size != null)
        {
            // Sized array: int[] arr = new int[10];
            var size = node.Size.Accept(this);
            return $"{elementType}[] {varName} = new {elementType}[{size}];";
        }
        else if (node.Initializer.Count > 0)
        {
            // Initialized array: int[] arr = { 1, 2, 3 };
            var elements = string.Join(", ", node.Initializer.Select(e => e.Accept(this)));
            return $"{elementType}[] {varName} = {{ {elements} }};";
        }
        else
        {
            // Empty array
            return $"{elementType}[] {varName} = Array.Empty<{elementType}>();";
        }
    }

    public string Visit(ArrayAccessNode node)
    {
        var array = node.Array.Accept(this);
        var index = node.Index.Accept(this);
        return $"{array}[{index}]";
    }

    public string Visit(ArrayLengthNode node)
    {
        var array = node.Array.Accept(this);
        return $"{array}.Length";
    }

    public string Visit(ForeachStatementNode node)
    {
        var varType = MapTypeName(node.VariableType);
        var varName = SanitizeIdentifier(node.VariableName);
        var collection = node.Collection.Accept(this);

        AppendLine($"foreach ({varType} {varName} in {collection})");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            var stmtCode = stmt.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    // Phase 7: Generics

    public string Visit(TypeParameterNode node)
    {
        // Type parameters are handled in function/method signature emission
        return node.Name;
    }

    public string Visit(TypeConstraintNode node)
    {
        return EmitConstraint(node);
    }

    public string Visit(GenericTypeNode node)
    {
        var typeName = MapTypeName(node.TypeName);
        if (node.TypeArguments.Count == 0)
        {
            return typeName;
        }

        var typeArgs = string.Join(", ", node.TypeArguments.Select(MapTypeName));
        return $"{typeName}<{typeArgs}>";
    }

    private string EmitConstraint(TypeConstraintNode constraint)
    {
        return constraint.Kind switch
        {
            TypeConstraintKind.Class => "class",
            TypeConstraintKind.Struct => "struct",
            TypeConstraintKind.New => "new()",
            TypeConstraintKind.Interface => constraint.TypeName ?? "object",
            TypeConstraintKind.BaseClass => constraint.TypeName ?? "object",
            TypeConstraintKind.TypeName => MapTypeName(constraint.TypeName ?? "object"),
            _ => "object"
        };
    }

    // Phase 8: Classes, Interfaces, Inheritance

    public string Visit(InterfaceDefinitionNode node)
    {
        EmitCSharpAttributes(node.CSharpAttributes);

        var name = SanitizeIdentifier(node.Name);

        // Build type parameters
        var typeParams = "";
        var whereClause = "";
        if (node.TypeParameters.Count > 0)
        {
            typeParams = "<" + string.Join(", ", node.TypeParameters.Select(tp => tp.Name)) + ">";

            // Build where clauses
            var whereClauses = new List<string>();
            foreach (var tp in node.TypeParameters)
            {
                if (tp.Constraints.Count > 0)
                {
                    var constraints = string.Join(", ", tp.Constraints.Select(c => EmitConstraint(c)));
                    whereClauses.Add($"where {tp.Name} : {constraints}");
                }
            }
            if (whereClauses.Count > 0)
            {
                whereClause = " " + string.Join(" ", whereClauses);
            }
        }

        var baseList = node.BaseInterfaces.Count > 0
            ? " : " + string.Join(", ", node.BaseInterfaces.Select(SanitizeIdentifier))
            : "";

        AppendLine($"public interface {name}{typeParams}{baseList}{whereClause}");
        AppendLine("{");
        Indent();

        foreach (var method in node.Methods)
        {
            Visit(method);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(MethodSignatureNode node)
    {
        EmitCSharpAttributes(node.CSharpAttributes);

        var returnType = node.Output?.TypeName ?? "void";
        var mappedReturnType = MapTypeName(returnType);
        var methodName = SanitizeIdentifier(node.Name);

        var typeParams = "";
        var whereClause = "";
        if (node.TypeParameters.Count > 0)
        {
            typeParams = "<" + string.Join(", ", node.TypeParameters.Select(tp => tp.Name)) + ">";

            // Build where clauses
            var whereClauses = new List<string>();
            foreach (var tp in node.TypeParameters)
            {
                if (tp.Constraints.Count > 0)
                {
                    var constraints = string.Join(", ", tp.Constraints.Select(c => EmitConstraint(c)));
                    whereClauses.Add($"where {tp.Name} : {constraints}");
                }
            }
            if (whereClauses.Count > 0)
            {
                whereClause = " " + string.Join(" ", whereClauses);
            }
        }

        var parameters = string.Join(", ", node.Parameters.Select(p =>
            $"{MapTypeName(p.TypeName)} {SanitizeIdentifier(p.Name)}"));

        AppendLine($"{mappedReturnType} {methodName}{typeParams}({parameters}){whereClause};");

        return "";
    }

    public string Visit(ClassDefinitionNode node)
    {
        EmitCSharpAttributes(node.CSharpAttributes);

        var name = SanitizeIdentifier(node.Name);

        var modifiers = "public";
        if (node.IsAbstract) modifiers += " abstract";
        if (node.IsSealed) modifiers += " sealed";

        // Build type parameters
        var typeParams = "";
        var whereClause = "";
        if (node.TypeParameters.Count > 0)
        {
            typeParams = "<" + string.Join(", ", node.TypeParameters.Select(tp => tp.Name)) + ">";

            var whereClauses = new List<string>();
            foreach (var tp in node.TypeParameters)
            {
                if (tp.Constraints.Count > 0)
                {
                    var constraints = string.Join(", ", tp.Constraints.Select(c => EmitConstraint(c)));
                    whereClauses.Add($"where {tp.Name} : {constraints}");
                }
            }
            if (whereClauses.Count > 0)
            {
                whereClause = " " + string.Join(" ", whereClauses);
            }
        }

        // Build inheritance list
        var baseList = new List<string>();
        if (!string.IsNullOrEmpty(node.BaseClass))
        {
            baseList.Add(SanitizeIdentifier(node.BaseClass));
        }
        baseList.AddRange(node.ImplementedInterfaces.Select(SanitizeIdentifier));
        var inheritance = baseList.Count > 0 ? " : " + string.Join(", ", baseList) : "";

        AppendLine($"{modifiers} class {name}{typeParams}{inheritance}{whereClause}");
        AppendLine("{");
        Indent();

        // Set current class name for constructor emission
        _currentClassName = name;

        // Emit fields
        foreach (var field in node.Fields)
        {
            Visit(field);
        }

        // Emit properties
        foreach (var prop in node.Properties)
        {
            Visit(prop);
            AppendLine();
        }

        // Emit constructors
        foreach (var ctor in node.Constructors)
        {
            Visit(ctor);
            AppendLine();
        }

        // Emit methods
        foreach (var method in node.Methods)
        {
            Visit(method);
            AppendLine();
        }

        // Emit events
        foreach (var evt in node.Events)
        {
            Visit(evt);
        }

        _currentClassName = null;

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(ClassFieldNode node)
    {
        EmitCSharpAttributes(node.CSharpAttributes);

        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "private"
        };

        var typeName = MapTypeName(node.TypeName);
        var fieldName = SanitizeIdentifier(node.Name);

        if (node.DefaultValue != null)
        {
            var defaultVal = node.DefaultValue.Accept(this);
            AppendLine($"{visibility} {typeName} {fieldName} = {defaultVal};");
        }
        else
        {
            AppendLine($"{visibility} {typeName} {fieldName};");
        }

        return "";
    }

    public string Visit(MethodNode node)
    {
        EmitCSharpAttributes(node.CSharpAttributes);

        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "private"
        };

        var modifiers = new List<string> { visibility };
        if (node.IsStatic) modifiers.Add("static");
        if (node.IsAbstract) modifiers.Add("abstract");
        else if (node.IsVirtual) modifiers.Add("virtual");
        if (node.IsOverride) modifiers.Add("override");
        if (node.IsSealed && node.IsOverride) modifiers.Add("sealed");

        var returnType = node.Output?.TypeName ?? "void";
        var mappedReturnType = MapTypeName(returnType);
        var hasReturnValue = returnType.ToUpperInvariant() != "VOID";
        var methodName = SanitizeIdentifier(node.Name);

        // Build type parameters
        var typeParams = "";
        var whereClause = "";
        if (node.TypeParameters.Count > 0)
        {
            typeParams = "<" + string.Join(", ", node.TypeParameters.Select(tp => tp.Name)) + ">";

            var whereClauses = new List<string>();
            foreach (var tp in node.TypeParameters)
            {
                if (tp.Constraints.Count > 0)
                {
                    var constraints = string.Join(", ", tp.Constraints.Select(c => EmitConstraint(c)));
                    whereClauses.Add($"where {tp.Name} : {constraints}");
                }
            }
            if (whereClauses.Count > 0)
            {
                whereClause = " " + string.Join(" ", whereClauses);
            }
        }

        var parameters = string.Join(", ", node.Parameters.Select(p =>
            $"{MapTypeName(p.TypeName)} {SanitizeIdentifier(p.Name)}"));

        // Abstract methods have no body
        if (node.IsAbstract)
        {
            AppendLine($"{string.Join(" ", modifiers)} {mappedReturnType} {methodName}{typeParams}({parameters}){whereClause};");
            return "";
        }

        AppendLine($"{string.Join(" ", modifiers)} {mappedReturnType} {methodName}{typeParams}({parameters}){whereClause}");
        AppendLine("{");
        Indent();

        // Emit preconditions
        foreach (var requires in node.Preconditions)
        {
            var check = Visit(requires);
            AppendLine(check);
        }

        // Handle postconditions similar to FunctionNode
        if (node.Postconditions.Count > 0 && hasReturnValue)
        {
            AppendLine($"{mappedReturnType} __result__ = default;");
            AppendLine();

            foreach (var statement in node.Body)
            {
                if (statement is ReturnStatementNode returnStmt && returnStmt.Expression != null)
                {
                    var expr = returnStmt.Expression.Accept(this);
                    AppendLine($"__result__ = {expr};");
                }
                else
                {
                    var stmtCode = statement.Accept(this);
                    AppendLine(stmtCode);
                }
            }

            AppendLine();
            foreach (var ensures in node.Postconditions)
            {
                var check = Visit(ensures).Replace("result", "__result__");
                AppendLine(check);
            }

            AppendLine("return __result__;");
        }
        else
        {
            foreach (var statement in node.Body)
            {
                var stmtCode = statement.Accept(this);
                AppendLine(stmtCode);
            }

            foreach (var ensures in node.Postconditions)
            {
                var check = Visit(ensures);
                AppendLine(check);
            }
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(NewExpressionNode node)
    {
        var typeName = SanitizeIdentifier(node.TypeName);
        if (node.TypeArguments.Count > 0)
        {
            typeName += "<" + string.Join(", ", node.TypeArguments.Select(MapTypeName)) + ">";
        }

        var args = string.Join(", ", node.Arguments.Select(a => a.Accept(this)));
        return $"new {typeName}({args})";
    }

    public string Visit(CallExpressionNode node)
    {
        // Unescape braces that were escaped for Calor syntax: \{ -> { and \} -> }
        var target = UnescapeBraces(node.Target);
        var args = string.Join(", ", node.Arguments.Select(a => a.Accept(this)));
        return $"{target}({args})";
    }

    /// <summary>
    /// Unescapes braces that were escaped for Calor syntax.
    /// \{ becomes { and \} becomes }
    /// </summary>
    private static string UnescapeBraces(string input)
    {
        if (!input.Contains('\\'))
            return input;

        return input.Replace("\\{", "{").Replace("\\}", "}");
    }

    public string Visit(ThisExpressionNode node)
    {
        return "this";
    }

    public string Visit(BaseExpressionNode node)
    {
        return "base";
    }

    // Phase 9: Properties and Constructors

    public string Visit(PropertyNode node)
    {
        EmitCSharpAttributes(node.CSharpAttributes);

        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "public"
        };

        var typeName = MapTypeName(node.TypeName);
        var propName = SanitizeIdentifier(node.Name);

        // Auto-property with default value
        if (node.IsAutoProperty)
        {
            if (node.DefaultValue != null)
            {
                var defaultVal = node.DefaultValue.Accept(this);
                AppendLine($"{visibility} {typeName} {propName} {{ get; set; }} = {defaultVal};");
            }
            else
            {
                AppendLine($"{visibility} {typeName} {propName} {{ get; set; }}");
            }
            return "";
        }

        // Property with accessors
        AppendLine($"{visibility} {typeName} {propName}");
        AppendLine("{");
        Indent();

        if (node.Getter != null)
        {
            Visit(node.Getter);
        }

        if (node.Setter != null)
        {
            Visit(node.Setter);
        }

        if (node.Initer != null)
        {
            Visit(node.Initer);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(PropertyAccessorNode node)
    {
        var accessorKeyword = node.Kind switch
        {
            PropertyAccessorNode.AccessorKind.Get => "get",
            PropertyAccessorNode.AccessorKind.Set => "set",
            PropertyAccessorNode.AccessorKind.Init => "init",
            _ => "get"
        };

        var visibilityPrefix = node.Visibility switch
        {
            Visibility.Private => "private ",
            Visibility.Internal => "internal ",
            Visibility.Protected => "protected ",
            _ => ""
        };

        if (node.IsAutoImplemented)
        {
            AppendLine($"{visibilityPrefix}{accessorKeyword};");
        }
        else
        {
            AppendLine($"{visibilityPrefix}{accessorKeyword}");
            AppendLine("{");
            Indent();

            foreach (var pre in node.Preconditions)
            {
                AppendLine(Visit(pre));
            }

            foreach (var stmt in node.Body)
            {
                AppendLine(stmt.Accept(this));
            }

            Dedent();
            AppendLine("}");
        }

        return "";
    }

    public string Visit(ConstructorNode node)
    {
        EmitCSharpAttributes(node.CSharpAttributes);

        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "public"
        };

        // Constructor name is the class name
        var ctorName = _currentClassName ?? "UnknownClass";
        var parameters = string.Join(", ", node.Parameters.Select(p =>
            $"{MapTypeName(p.TypeName)} {SanitizeIdentifier(p.Name)}"));

        var initializerStr = "";
        if (node.Initializer != null)
        {
            var initArgs = string.Join(", ", node.Initializer.Arguments.Select(a => a.Accept(this)));
            initializerStr = node.Initializer.IsBaseCall ? $" : base({initArgs})" : $" : this({initArgs})";
        }

        AppendLine($"{visibility} {ctorName}({parameters}){initializerStr}");
        AppendLine("{");
        Indent();

        foreach (var pre in node.Preconditions)
        {
            AppendLine(Visit(pre));
        }

        foreach (var stmt in node.Body)
        {
            AppendLine(stmt.Accept(this));
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(ConstructorInitializerNode node)
    {
        var args = string.Join(", ", node.Arguments.Select(a => a.Accept(this)));
        return node.IsBaseCall ? $"base({args})" : $"this({args})";
    }

    public string Visit(AssignmentStatementNode node)
    {
        var target = node.Target.Accept(this);
        var value = node.Value.Accept(this);
        return $"{target} = {value};";
    }

    public string Visit(CompoundAssignmentStatementNode node)
    {
        var target = node.Target.Accept(this);
        var value = node.Value.Accept(this);
        var op = node.Operator switch
        {
            CompoundAssignmentOperator.Add => "+=",
            CompoundAssignmentOperator.Subtract => "-=",
            CompoundAssignmentOperator.Multiply => "*=",
            CompoundAssignmentOperator.Divide => "/=",
            CompoundAssignmentOperator.Modulo => "%=",
            CompoundAssignmentOperator.BitwiseAnd => "&=",
            CompoundAssignmentOperator.BitwiseOr => "|=",
            CompoundAssignmentOperator.BitwiseXor => "^=",
            CompoundAssignmentOperator.LeftShift => "<<=",
            CompoundAssignmentOperator.RightShift => ">>=",
            _ => "+="
        };
        return $"{target} {op} {value};";
    }

    public string Visit(UsingStatementNode node)
    {
        var typePart = node.VariableType != null ? MapTypeName(node.VariableType) : "var";
        var namePart = node.VariableName != null ? SanitizeIdentifier(node.VariableName) : "_";
        var resource = node.Resource.Accept(this);

        AppendLine($"using ({typePart} {namePart} = {resource})");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            AppendLine(stmt.Accept(this));
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    // Phase 10: Try/Catch/Finally

    public string Visit(TryStatementNode node)
    {
        AppendLine("try");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.TryBody)
        {
            AppendLine(stmt.Accept(this));
        }

        Dedent();
        AppendLine("}");

        foreach (var catchClause in node.CatchClauses)
        {
            Visit(catchClause);
        }

        if (node.FinallyBody != null)
        {
            AppendLine("finally");
            AppendLine("{");
            Indent();

            foreach (var stmt in node.FinallyBody)
            {
                AppendLine(stmt.Accept(this));
            }

            Dedent();
            AppendLine("}");
        }

        return "";
    }

    public string Visit(CatchClauseNode node)
    {
        var catchPart = "catch";
        if (node.ExceptionType != null)
        {
            var exType = SanitizeIdentifier(node.ExceptionType);
            if (node.VariableName != null)
            {
                var varName = SanitizeIdentifier(node.VariableName);
                catchPart = $"catch ({exType} {varName})";
            }
            else
            {
                catchPart = $"catch ({exType})";
            }
        }

        if (node.Filter != null)
        {
            var filter = node.Filter.Accept(this);
            catchPart += $" when ({filter})";
        }

        AppendLine(catchPart);
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            AppendLine(stmt.Accept(this));
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(ThrowStatementNode node)
    {
        if (node.Exception != null)
        {
            var exception = node.Exception.Accept(this);
            return $"throw {exception};";
        }
        return "throw;";
    }

    public string Visit(RethrowStatementNode node)
    {
        return "throw;";
    }

    // Phase 11: Lambdas, Delegates, Events

    public string Visit(LambdaParameterNode node)
    {
        if (node.TypeName != null)
        {
            return $"{MapTypeName(node.TypeName)} {SanitizeIdentifier(node.Name)}";
        }
        return SanitizeIdentifier(node.Name);
    }

    public string Visit(LambdaExpressionNode node)
    {
        var async = node.IsAsync ? "async " : "";
        var parameters = node.Parameters.Count switch
        {
            0 => "()",
            1 when node.Parameters[0].TypeName == null => SanitizeIdentifier(node.Parameters[0].Name),
            _ => "(" + string.Join(", ", node.Parameters.Select(p => Visit(p))) + ")"
        };

        if (node.IsExpressionLambda && node.ExpressionBody != null)
        {
            var body = node.ExpressionBody.Accept(this);
            return $"{async}{parameters} => {body}";
        }
        else if (node.StatementBody != null && node.StatementBody.Count > 0)
        {
            var sb = new StringBuilder();
            sb.Append($"{async}{parameters} => {{\n");
            foreach (var stmt in node.StatementBody)
            {
                sb.Append($"    {stmt.Accept(this)}\n");
            }
            sb.Append("}");
            return sb.ToString();
        }

        return $"{async}{parameters} => default";
    }

    public string Visit(DelegateDefinitionNode node)
    {
        var name = SanitizeIdentifier(node.Name);
        var returnType = node.Output?.TypeName ?? "void";
        var mappedReturnType = MapTypeName(returnType);
        var parameters = string.Join(", ", node.Parameters.Select(p =>
            $"{MapTypeName(p.TypeName)} {SanitizeIdentifier(p.Name)}"));

        AppendLine($"public delegate {mappedReturnType} {name}({parameters});");
        return "";
    }

    public string Visit(EventDefinitionNode node)
    {
        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "public"
        };

        var eventName = SanitizeIdentifier(node.Name);
        var delegateType = SanitizeIdentifier(node.DelegateType);

        AppendLine($"{visibility} event {delegateType} {eventName};");
        return "";
    }

    public string Visit(EventSubscribeNode node)
    {
        var @event = node.Event.Accept(this);
        var handler = node.Handler.Accept(this);
        return $"{@event} += {handler};";
    }

    public string Visit(EventUnsubscribeNode node)
    {
        var @event = node.Event.Accept(this);
        var handler = node.Handler.Accept(this);
        return $"{@event} -= {handler};";
    }

    // Phase 12: Async/Await

    public string Visit(AwaitExpressionNode node)
    {
        var awaited = node.Awaited.Accept(this);

        // Handle ConfigureAwait if specified
        if (node.ConfigureAwait.HasValue)
        {
            var configValue = node.ConfigureAwait.Value ? "true" : "false";
            return $"await {awaited}.ConfigureAwait({configValue})";
        }

        return $"await {awaited}";
    }

    // Phase 9: String Interpolation and Modern Operators

    public string Visit(InterpolatedStringNode node)
    {
        var sb = new StringBuilder();
        sb.Append("$\"");

        foreach (var part in node.Parts)
        {
            if (part is InterpolatedStringTextNode textPart)
            {
                // Escape quotes and braces in literal text
                var escaped = textPart.Text
                    .Replace("\\", "\\\\")
                    .Replace("\"", "\\\"")
                    .Replace("{", "{{")
                    .Replace("}", "}}");
                sb.Append(escaped);
            }
            else if (part is InterpolatedStringExpressionNode exprPart)
            {
                sb.Append("{");
                sb.Append(exprPart.Expression.Accept(this));
                sb.Append("}");
            }
        }

        sb.Append("\"");
        return sb.ToString();
    }

    public string Visit(InterpolatedStringTextNode node)
    {
        // This is typically only called standalone, not as part of interpolation
        return node.Text;
    }

    public string Visit(InterpolatedStringExpressionNode node)
    {
        // This is typically only called standalone, not as part of interpolation
        return node.Expression.Accept(this);
    }

    public string Visit(NullCoalesceNode node)
    {
        var left = node.Left.Accept(this);
        var right = node.Right.Accept(this);
        return $"{left} ?? {right}";
    }

    public string Visit(NullConditionalNode node)
    {
        var target = node.Target.Accept(this);
        return $"{target}?.{SanitizeIdentifier(node.MemberName)}";
    }

    public string Visit(RangeExpressionNode node)
    {
        var start = node.Start?.Accept(this) ?? "";
        var end = node.End?.Accept(this) ?? "";
        return $"{start}..{end}";
    }

    public string Visit(IndexFromEndNode node)
    {
        var offset = node.Offset.Accept(this);
        return $"^{offset}";
    }

    // Phase 10: Advanced Patterns

    public string Visit(WithExpressionNode node)
    {
        var target = node.Target.Accept(this);
        var assignments = string.Join(", ", node.Assignments.Select(a =>
            $"{SanitizeIdentifier(a.PropertyName)} = {a.Value.Accept(this)}"));
        return $"{target} with {{ {assignments} }}";
    }

    public string Visit(WithPropertyAssignmentNode node)
    {
        var value = node.Value.Accept(this);
        return $"{SanitizeIdentifier(node.PropertyName)} = {value}";
    }

    public string Visit(PositionalPatternNode node)
    {
        var patterns = string.Join(", ", node.Patterns.Select(p => p.Accept(this)));
        return $"{SanitizeIdentifier(node.TypeName)}({patterns})";
    }

    public string Visit(PropertyPatternNode node)
    {
        var matches = string.Join(", ", node.Matches.Select(m => m.Accept(this)));
        var typePart = string.IsNullOrEmpty(node.TypeName) ? "" : SanitizeIdentifier(node.TypeName) + " ";
        return $"{typePart}{{ {matches} }}";
    }

    public string Visit(PropertyMatchNode node)
    {
        var pattern = node.Pattern.Accept(this);
        return $"{SanitizeIdentifier(node.PropertyName)}: {pattern}";
    }

    public string Visit(RelationalPatternNode node)
    {
        var value = node.Value.Accept(this);
        var op = node.Operator.ToLowerInvariant() switch
        {
            "lt" => "<",
            "lte" => "<=",
            "gt" => ">",
            "gte" => ">=",
            "eq" => "",
            _ => node.Operator
        };
        return string.IsNullOrEmpty(op) ? value : $"{op} {value}";
    }

    public string Visit(ListPatternNode node)
    {
        var parts = new List<string>();
        foreach (var pattern in node.Patterns)
        {
            parts.Add(pattern.Accept(this));
        }
        if (node.SlicePattern != null)
        {
            parts.Add($"..{node.SlicePattern.Accept(this)}");
        }
        return $"[{string.Join(", ", parts)}]";
    }

    public string Visit(VarPatternNode node)
    {
        return $"var {SanitizeIdentifier(node.Name)}";
    }

    public string Visit(ConstantPatternNode node)
    {
        return node.Value.Accept(this);
    }

    #region Extended Features Visit Methods

    /// <summary>
    /// Emits Debug.Assert for an inline example/test.
    /// </summary>
    public string Visit(ExampleNode node)
    {
        var expr = node.Expression.Accept(this);
        var expected = node.Expected.Accept(this);
        var message = node.Message ?? $"Example {node.Id ?? ""}";
        return $"System.Diagnostics.Debug.Assert(object.Equals({expr}, {expected}), \"{EscapeString(message)}\");";
    }

    /// <summary>
    /// Emits a structured comment for issues (TODO, FIXME, HACK).
    /// </summary>
    public string Visit(IssueNode node)
    {
        var idPart = node.Id != null ? $"[{node.Id}]" : "";
        var categoryPart = node.Category != null ? $"({node.Category})" : "";
        var priorityPart = node.Priority != IssuePriority.Medium ? $" [{node.Priority}]" : "";
        return $"// {node.Kind.ToString().ToUpperInvariant()}{idPart}{categoryPart}{priorityPart}: {node.Description}";
    }

    /// <summary>
    /// Emits nothing for dependency nodes (used as part of Uses/UsedBy).
    /// </summary>
    public string Visit(DependencyNode node)
    {
        var versionPart = node.Version != null ? $"@{node.Version}" : "";
        var optionalPart = node.IsOptional ? "?" : "";
        return $"{node.Target}{versionPart}{optionalPart}";
    }

    /// <summary>
    /// Emits a comment for USES declarations.
    /// </summary>
    public string Visit(UsesNode node)
    {
        if (node.Dependencies.Count == 0)
            return "";

        var deps = string.Join(", ", node.Dependencies.Select(d => d.Accept(this)));
        return $"// USES: {deps}";
    }

    /// <summary>
    /// Emits a comment for USEDBY declarations.
    /// </summary>
    public string Visit(UsedByNode node)
    {
        if (node.Dependents.Count == 0 && !node.HasUnknownCallers)
            return "";

        var deps = string.Join(", ", node.Dependents.Select(d => d.Accept(this)));
        var unknownPart = node.HasUnknownCallers ? (deps.Length > 0 ? ", [external]" : "[external]") : "";
        return $"// USEDBY: {deps}{unknownPart}";
    }

    /// <summary>
    /// Emits a comment for ASSUME declarations.
    /// </summary>
    public string Visit(AssumeNode node)
    {
        var categoryPart = node.Category.HasValue ? $"[{node.Category.Value.ToString().ToLowerInvariant()}]" : "";
        return $"// ASSUME{categoryPart}: {node.Description}";
    }

    /// <summary>
    /// Emits a comment for COMPLEXITY declarations.
    /// </summary>
    public string Visit(ComplexityNode node)
    {
        var parts = new List<string>();
        var prefix = node.IsWorstCase ? "Worst-case " : "";

        if (node.TimeComplexity.HasValue)
            parts.Add($"time: {FormatComplexity(node.TimeComplexity.Value)}");
        if (node.SpaceComplexity.HasValue)
            parts.Add($"space: {FormatComplexity(node.SpaceComplexity.Value)}");
        if (node.CustomExpression != null)
            parts.Add(node.CustomExpression);

        if (parts.Count == 0)
            return "";

        return $"// COMPLEXITY: {prefix}{string.Join(", ", parts)}";
    }

    private static string FormatComplexity(ComplexityClass c)
    {
        return c switch
        {
            ComplexityClass.O1 => "O(1)",
            ComplexityClass.OLogN => "O(log n)",
            ComplexityClass.ON => "O(n)",
            ComplexityClass.ONLogN => "O(n log n)",
            ComplexityClass.ON2 => "O(n)",
            ComplexityClass.ON3 => "O(n)",
            ComplexityClass.O2N => "O(2)",
            ComplexityClass.ONFact => "O(n!)",
            _ => c.ToString()
        };
    }

    /// <summary>
    /// Emits a comment for SINCE declarations.
    /// </summary>
    public string Visit(SinceNode node)
    {
        return $"// SINCE: {node.Version}";
    }

    /// <summary>
    /// Emits an [Obsolete] attribute for DEPRECATED declarations.
    /// </summary>
    public string Visit(DeprecatedNode node)
    {
        var parts = new List<string>();
        parts.Add($"Deprecated since {node.SinceVersion}");

        if (node.Replacement != null)
            parts.Add($"Use {node.Replacement} instead");
        if (node.Reason != null)
            parts.Add(node.Reason);
        if (node.RemovedInVersion != null)
            parts.Add($"Will be removed in {node.RemovedInVersion}");

        var message = string.Join(". ", parts);
        return $"[System.Obsolete(\"{EscapeString(message)}\")]";
    }

    /// <summary>
    /// Emits a comment for BREAKING declarations.
    /// </summary>
    public string Visit(BreakingChangeNode node)
    {
        return $"// BREAKING CHANGE ({node.Version}): {node.Description}";
    }

    /// <summary>
    /// Emits documentation comment for a DECISION record.
    /// </summary>
    public string Visit(DecisionNode node)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"// DECISION[{node.Id}]: {node.Title}");
        sb.AppendLine($"// Chosen: {node.ChosenOption}");
        foreach (var reason in node.ChosenReasons)
        {
            sb.AppendLine($"//   Reason: {reason}");
        }
        foreach (var rejected in node.RejectedOptions)
        {
            var rejectedText = Visit(rejected);
            foreach (var line in rejectedText.Split('\n'))
            {
                sb.AppendLine(line);
            }
        }
        if (node.Context != null)
            sb.AppendLine($"// Context: {node.Context}");
        if (node.Date.HasValue)
            sb.AppendLine($"// Date: {node.Date.Value:yyyy-MM-dd}");
        if (node.Author != null)
            sb.AppendLine($"// Author: {node.Author}");

        return sb.ToString().TrimEnd();
    }

    /// <summary>
    /// Emits documentation for a rejected option in a decision record.
    /// </summary>
    public string Visit(RejectedOptionNode node)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"// Rejected: {node.Name}");
        foreach (var reason in node.Reasons)
        {
            sb.AppendLine($"//   Reason: {reason}");
        }
        return sb.ToString().TrimEnd();
    }

    /// <summary>
    /// Emits a comment for CONTEXT partial view markers.
    /// </summary>
    public string Visit(ContextNode node)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"// CONTEXT{(node.IsPartial ? " (partial)" : "")}");

        if (node.VisibleFiles.Count > 0)
        {
            sb.AppendLine("// Visible:");
            foreach (var file in node.VisibleFiles)
            {
                sb.AppendLine($"//   - {file.FilePath}{(file.Description != null ? $" ({file.Description})" : "")}");
            }
        }

        if (node.HiddenFiles.Count > 0)
        {
            sb.AppendLine("// Hidden:");
            foreach (var file in node.HiddenFiles)
            {
                sb.AppendLine($"//   - {file.FilePath}{(file.Description != null ? $" ({file.Description})" : "")}");
            }
        }

        if (node.FocusTarget != null)
            sb.AppendLine($"// Focus: {node.FocusTarget}");

        return sb.ToString().TrimEnd();
    }

    /// <summary>
    /// Emits a comment for FILE references.
    /// </summary>
    public string Visit(FileRefNode node)
    {
        var descPart = node.Description != null ? $" ({node.Description})" : "";
        return $"// FILE: {node.FilePath}{descPart}";
    }

    /// <summary>
    /// Emits a property-based test method stub.
    /// </summary>
    public string Visit(PropertyTestNode node)
    {
        var quantifiers = node.Quantifiers.Count > 0
            ? $"{string.Join(",", node.Quantifiers)}: "
            : "";
        var predicate = node.Predicate.Accept(this);
        return $"// PROPERTY: {quantifiers}{predicate}";
    }

    /// <summary>
    /// Emits a comment for LOCK declarations.
    /// </summary>
    public string Visit(LockNode node)
    {
        var parts = new List<string> { $"agent={node.AgentId}" };
        if (node.Acquired.HasValue)
            parts.Add($"acquired={node.Acquired.Value:O}");
        if (node.Expires.HasValue)
            parts.Add($"expires={node.Expires.Value:O}");

        return $"// LOCK: {string.Join(", ", parts)}";
    }

    /// <summary>
    /// Emits a comment for AUTHOR declarations.
    /// </summary>
    public string Visit(AuthorNode node)
    {
        var parts = new List<string> { $"agent={node.AgentId}", $"date={node.Date:yyyy-MM-dd}" };
        if (node.TaskId != null)
            parts.Add($"task={node.TaskId}");

        return $"// AUTHOR: {string.Join(", ", parts)}";
    }

    /// <summary>
    /// Emits a comment for TASK references.
    /// </summary>
    public string Visit(TaskRefNode node)
    {
        return $"// TASK[{node.TaskId}]: {node.Description}";
    }

    #endregion

    private string GetInferredTypeName(ExpressionNode expr)
    {
        return expr switch
        {
            IntLiteralNode => "int",
            FloatLiteralNode => "double",
            BoolLiteralNode => "bool",
            StringLiteralNode => "string",
            _ => "object"
        };
    }

    private static string MapTypeName(string calorType)
    {
        // Use the centralized TypeMapper for bidirectional type mapping
        return TypeMapper.CalorToCSharp(calorType);
    }

    private static string SanitizeIdentifier(string name)
    {
        // Replace any characters that aren't valid in C# identifiers
        var sb = new StringBuilder();
        for (int i = 0; i < name.Length; i++)
        {
            var c = name[i];
            if (char.IsLetterOrDigit(c) || c == '_')
            {
                sb.Append(c);
            }
            else if (c == '.')
            {
                sb.Append('_');
            }
        }

        var result = sb.ToString();

        // Ensure identifier doesn't start with a digit
        if (result.Length > 0 && char.IsDigit(result[0]))
        {
            result = "_" + result;
        }

        // Handle reserved words
        return result switch
        {
            "class" or "struct" or "interface" or "enum" or
            "namespace" or "using" or "public" or "private" or
            "protected" or "internal" or "static" or "void" or
            "int" or "string" or "bool" or "float" or "double" or
            "return" or "if" or "else" or "for" or "while" or
            "do" or "switch" or "case" or "break" or "continue" or
            "new" or "this" or "base" or "null" or "true" or "false"
            => "@" + result,
            _ => result
        };
    }

    /// <summary>
    /// Emits C#-style attributes.
    /// </summary>
    private void EmitCSharpAttributes(IReadOnlyList<CalorAttributeNode> attributes)
    {
        foreach (var attr in attributes)
        {
            AppendLine(Visit(attr));
        }
    }

    public string Visit(CalorAttributeNode node)
    {
        if (node.Arguments.Count == 0)
        {
            return $"[{node.Name}]";
        }

        var args = string.Join(", ", node.Arguments.Select(FormatCSharpAttributeArgument));
        return $"[{node.Name}({args})]";
    }

    private static string FormatCSharpAttributeArgument(CalorAttributeArgument arg)
    {
        var value = arg.GetFormattedValue();

        if (arg.IsNamed)
        {
            return $"{arg.Name} = {value}";
        }
        return value;
    }
}

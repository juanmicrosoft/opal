using System.Text;
using Opal.Compiler.Ast;

namespace Opal.Compiler.CodeGen;

/// <summary>
/// Emits C# source code from an OPAL AST.
/// </summary>
public sealed class CSharpEmitter : IAstVisitor<string>
{
    private readonly StringBuilder _builder = new();
    private int _indentLevel;

    public string Emit(ModuleNode module)
    {
        _builder.Clear();
        _indentLevel = 0;

        var result = Visit(module);
        return result;
    }

    private void AppendLine(string line = "")
    {
        if (string.IsNullOrEmpty(line))
        {
            _builder.AppendLine();
        }
        else
        {
            _builder.Append(new string(' ', _indentLevel * 4));
            _builder.AppendLine(line);
        }
    }

    private void Indent() => _indentLevel++;
    private void Dedent() => _indentLevel--;

    public string Visit(ModuleNode node)
    {
        AppendLine("// <auto-generated>");
        AppendLine("// This code was generated by the OPAL compiler.");
        AppendLine("// Do not modify this file directly.");
        AppendLine("// </auto-generated>");
        AppendLine();
        AppendLine("using System;");
        AppendLine();

        var namespaceName = SanitizeIdentifier(node.Name);
        AppendLine($"namespace {namespaceName}");
        AppendLine("{");
        Indent();

        AppendLine($"public static class {namespaceName}Module");
        AppendLine("{");
        Indent();

        foreach (var function in node.Functions)
        {
            Visit(function);
            AppendLine();
        }

        Dedent();
        AppendLine("}");

        Dedent();
        AppendLine("}");

        return _builder.ToString();
    }

    public string Visit(FunctionNode node)
    {
        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "private"
        };

        var returnType = node.Output?.TypeName ?? "void";
        var mappedReturnType = MapTypeName(returnType);

        var parameters = string.Join(", ", node.Parameters.Select(p =>
            $"{MapTypeName(p.TypeName)} {SanitizeIdentifier(p.Name)}"));

        var methodName = SanitizeIdentifier(node.Name);

        // Check if this is the entry point
        var isMain = node.Name.Equals("Main", StringComparison.OrdinalIgnoreCase);
        var staticKeyword = isMain ? "static " : "static ";

        AppendLine($"{visibility} {staticKeyword}{mappedReturnType} {methodName}({parameters})");
        AppendLine("{");
        Indent();

        foreach (var statement in node.Body)
        {
            var stmtCode = statement.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(ParameterNode node)
    {
        return $"{MapTypeName(node.TypeName)} {SanitizeIdentifier(node.Name)}";
    }

    public string Visit(CallStatementNode node)
    {
        var target = node.Target;
        var args = string.Join(", ", node.Arguments.Select(a => a.Accept(this)));

        return $"{target}({args});";
    }

    public string Visit(ReturnStatementNode node)
    {
        if (node.Expression == null)
        {
            return "return;";
        }

        var expr = node.Expression.Accept(this);
        return $"return {expr};";
    }

    public string Visit(IntLiteralNode node)
    {
        return node.Value.ToString();
    }

    public string Visit(StringLiteralNode node)
    {
        // Escape the string for C#
        var escaped = node.Value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");

        return $"\"{escaped}\"";
    }

    public string Visit(BoolLiteralNode node)
    {
        return node.Value ? "true" : "false";
    }

    public string Visit(FloatLiteralNode node)
    {
        return node.Value.ToString(System.Globalization.CultureInfo.InvariantCulture);
    }

    public string Visit(ReferenceNode node)
    {
        return SanitizeIdentifier(node.Name);
    }

    private static string MapTypeName(string opalType)
    {
        return opalType.ToUpperInvariant() switch
        {
            "VOID" => "void",
            "INT" => "int",
            "INT32" => "int",
            "INT64" => "long",
            "FLOAT" => "double",
            "FLOAT32" => "float",
            "FLOAT64" => "double",
            "BOOL" => "bool",
            "STRING" => "string",
            "STR" => "string",
            _ => opalType
        };
    }

    private static string SanitizeIdentifier(string name)
    {
        // Replace any characters that aren't valid in C# identifiers
        var sb = new StringBuilder();
        for (int i = 0; i < name.Length; i++)
        {
            var c = name[i];
            if (char.IsLetterOrDigit(c) || c == '_')
            {
                sb.Append(c);
            }
            else if (c == '.')
            {
                sb.Append('_');
            }
        }

        var result = sb.ToString();

        // Ensure identifier doesn't start with a digit
        if (result.Length > 0 && char.IsDigit(result[0]))
        {
            result = "_" + result;
        }

        // Handle reserved words
        return result switch
        {
            "class" or "struct" or "interface" or "enum" or
            "namespace" or "using" or "public" or "private" or
            "protected" or "internal" or "static" or "void" or
            "int" or "string" or "bool" or "float" or "double" or
            "return" or "if" or "else" or "for" or "while" or
            "do" or "switch" or "case" or "break" or "continue" or
            "new" or "this" or "base" or "null" or "true" or "false"
            => "@" + result,
            _ => result
        };
    }
}

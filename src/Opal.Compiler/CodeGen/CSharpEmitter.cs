using System.Text;
using Opal.Compiler.Ast;

namespace Opal.Compiler.CodeGen;

/// <summary>
/// Emits C# source code from an OPAL AST.
/// </summary>
public sealed class CSharpEmitter : IAstVisitor<string>
{
    private readonly StringBuilder _builder = new();
    private int _indentLevel;

    public string Emit(ModuleNode module)
    {
        _builder.Clear();
        _indentLevel = 0;

        var result = Visit(module);
        return result;
    }

    private void AppendLine(string line = "")
    {
        if (string.IsNullOrEmpty(line))
        {
            _builder.AppendLine();
        }
        else
        {
            _builder.Append(new string(' ', _indentLevel * 4));
            _builder.AppendLine(line);
        }
    }

    private void Indent() => _indentLevel++;
    private void Dedent() => _indentLevel--;

    public string Visit(ModuleNode node)
    {
        AppendLine("// <auto-generated>");
        AppendLine("// This code was generated by the OPAL compiler.");
        AppendLine("// Do not modify this file directly.");
        AppendLine("// </auto-generated>");
        AppendLine();
        AppendLine("using System;");
        AppendLine("using Opal.Runtime;");
        AppendLine();

        var namespaceName = SanitizeIdentifier(node.Name);
        AppendLine($"namespace {namespaceName}");
        AppendLine("{");
        Indent();

        AppendLine($"public static class {namespaceName}Module");
        AppendLine("{");
        Indent();

        foreach (var function in node.Functions)
        {
            Visit(function);
            AppendLine();
        }

        Dedent();
        AppendLine("}");

        Dedent();
        AppendLine("}");

        return _builder.ToString();
    }

    public string Visit(FunctionNode node)
    {
        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "private"
        };

        var returnType = node.Output?.TypeName ?? "void";
        var mappedReturnType = MapTypeName(returnType);

        var parameters = string.Join(", ", node.Parameters.Select(p =>
            $"{MapTypeName(p.TypeName)} {SanitizeIdentifier(p.Name)}"));

        var methodName = SanitizeIdentifier(node.Name);

        // Check if this is the entry point
        var isMain = node.Name.Equals("Main", StringComparison.OrdinalIgnoreCase);
        var staticKeyword = isMain ? "static " : "static ";

        AppendLine($"{visibility} {staticKeyword}{mappedReturnType} {methodName}({parameters})");
        AppendLine("{");
        Indent();

        foreach (var statement in node.Body)
        {
            var stmtCode = statement.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(ParameterNode node)
    {
        return $"{MapTypeName(node.TypeName)} {SanitizeIdentifier(node.Name)}";
    }

    public string Visit(CallStatementNode node)
    {
        var target = node.Target;
        var args = string.Join(", ", node.Arguments.Select(a => a.Accept(this)));

        return $"{target}({args});";
    }

    public string Visit(ReturnStatementNode node)
    {
        if (node.Expression == null)
        {
            return "return;";
        }

        var expr = node.Expression.Accept(this);
        return $"return {expr};";
    }

    public string Visit(IntLiteralNode node)
    {
        return node.Value.ToString();
    }

    public string Visit(StringLiteralNode node)
    {
        // Escape the string for C#
        var escaped = node.Value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");

        return $"\"{escaped}\"";
    }

    public string Visit(BoolLiteralNode node)
    {
        return node.Value ? "true" : "false";
    }

    public string Visit(FloatLiteralNode node)
    {
        return node.Value.ToString(System.Globalization.CultureInfo.InvariantCulture);
    }

    public string Visit(ReferenceNode node)
    {
        return SanitizeIdentifier(node.Name);
    }

    // Phase 2: Control Flow

    public string Visit(ForStatementNode node)
    {
        var varName = SanitizeIdentifier(node.VariableName);
        var from = node.From.Accept(this);
        var to = node.To.Accept(this);
        var step = node.Step?.Accept(this) ?? "1";

        // Determine loop direction based on step (simple heuristic)
        var isPositiveStep = !step.StartsWith("-");
        var comparison = isPositiveStep ? "<=" : ">=";
        var increment = step == "1" ? $"{varName}++" : $"{varName} += {step}";

        AppendLine($"for (var {varName} = {from}; {varName} {comparison} {to}; {increment})");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            var stmtCode = stmt.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(WhileStatementNode node)
    {
        var condition = node.Condition.Accept(this);

        AppendLine($"while ({condition})");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            var stmtCode = stmt.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(IfStatementNode node)
    {
        var condition = node.Condition.Accept(this);

        AppendLine($"if ({condition})");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.ThenBody)
        {
            var stmtCode = stmt.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine("}");

        // Emit ELSEIF clauses
        foreach (var elseIf in node.ElseIfClauses)
        {
            var elseIfCondition = elseIf.Condition.Accept(this);
            AppendLine($"else if ({elseIfCondition})");
            AppendLine("{");
            Indent();

            foreach (var stmt in elseIf.Body)
            {
                var stmtCode = stmt.Accept(this);
                AppendLine(stmtCode);
            }

            Dedent();
            AppendLine("}");
        }

        // Emit ELSE clause
        if (node.ElseBody != null)
        {
            AppendLine("else");
            AppendLine("{");
            Indent();

            foreach (var stmt in node.ElseBody)
            {
                var stmtCode = stmt.Accept(this);
                AppendLine(stmtCode);
            }

            Dedent();
            AppendLine("}");
        }

        return "";
    }

    public string Visit(BindStatementNode node)
    {
        var varName = SanitizeIdentifier(node.Name);
        var typeName = node.TypeName != null ? MapTypeName(node.TypeName) : "var";

        if (node.Initializer != null)
        {
            var initExpr = node.Initializer.Accept(this);
            return $"{typeName} {varName} = {initExpr};";
        }

        // No initializer - need explicit type
        if (node.TypeName == null)
        {
            typeName = "int"; // Default to int
        }
        return $"{typeName} {varName} = default;";
    }

    public string Visit(BinaryOperationNode node)
    {
        var left = node.Left.Accept(this);
        var right = node.Right.Accept(this);
        var op = node.Operator.ToCSharpOperator();

        return $"({left} {op} {right})";
    }

    // Phase 3: Type System

    public string Visit(RecordDefinitionNode node)
    {
        AppendLine($"public record {SanitizeIdentifier(node.Name)}(");
        Indent();

        for (int i = 0; i < node.Fields.Count; i++)
        {
            var field = node.Fields[i];
            var typeName = MapTypeName(field.TypeName);
            var fieldName = SanitizeIdentifier(field.Name);
            var comma = i < node.Fields.Count - 1 ? "," : "";
            AppendLine($"{typeName} {fieldName}{comma}");
        }

        Dedent();
        AppendLine(");");

        return "";
    }

    public string Visit(UnionTypeDefinitionNode node)
    {
        // Generate as abstract base class with derived classes for each variant
        var typeName = SanitizeIdentifier(node.Name);

        AppendLine($"public abstract record {typeName};");
        AppendLine();

        foreach (var variant in node.Variants)
        {
            var variantName = SanitizeIdentifier(variant.Name);
            if (variant.Fields.Count == 0)
            {
                AppendLine($"public sealed record {variantName}() : {typeName};");
            }
            else
            {
                var fields = string.Join(", ", variant.Fields.Select(f =>
                    $"{MapTypeName(f.TypeName)} {SanitizeIdentifier(f.Name)}"));
                AppendLine($"public sealed record {variantName}({fields}) : {typeName};");
            }
        }

        return "";
    }

    public string Visit(RecordCreationNode node)
    {
        var typeName = SanitizeIdentifier(node.TypeName);
        var fields = string.Join(", ", node.Fields.Select(f => f.Value.Accept(this)));
        return $"new {typeName}({fields})";
    }

    public string Visit(FieldAccessNode node)
    {
        var target = node.Target.Accept(this);
        var fieldName = SanitizeIdentifier(node.FieldName);
        return $"{target}.{fieldName}";
    }

    public string Visit(SomeExpressionNode node)
    {
        var value = node.Value.Accept(this);
        return $"Opal.Runtime.Option.Some({value})";
    }

    public string Visit(NoneExpressionNode node)
    {
        if (node.TypeName != null)
        {
            var typeName = MapTypeName(node.TypeName);
            return $"Opal.Runtime.Option<{typeName}>.None()";
        }
        return "Opal.Runtime.Option.None<object>()";
    }

    public string Visit(OkExpressionNode node)
    {
        var value = node.Value.Accept(this);
        return $"Opal.Runtime.Result.Ok<{GetInferredTypeName(node.Value)}, string>({value})";
    }

    public string Visit(ErrExpressionNode node)
    {
        var error = node.Error.Accept(this);
        return $"Opal.Runtime.Result.Err<object, {GetInferredTypeName(node.Error)}>({error})";
    }

    public string Visit(MatchExpressionNode node)
    {
        // Generate as switch expression
        var target = node.Target.Accept(this);
        var sb = new System.Text.StringBuilder();
        sb.Append($"{target} switch {{ ");

        for (int i = 0; i < node.Cases.Count; i++)
        {
            var matchCase = node.Cases[i];
            var pattern = EmitPattern(matchCase.Pattern);
            // For expression match, we'd need the body to be an expression
            // For now, emit a placeholder
            sb.Append($"{pattern} => default");
            if (i < node.Cases.Count - 1) sb.Append(", ");
        }

        sb.Append(" }");
        return sb.ToString();
    }

    public string Visit(MatchStatementNode node)
    {
        var target = node.Target.Accept(this);

        AppendLine($"switch ({target})");
        AppendLine("{");
        Indent();

        foreach (var matchCase in node.Cases)
        {
            var pattern = EmitPattern(matchCase.Pattern);
            AppendLine($"case {pattern}:");
            Indent();

            foreach (var stmt in matchCase.Body)
            {
                var stmtCode = stmt.Accept(this);
                AppendLine(stmtCode);
            }

            AppendLine("break;");
            Dedent();
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    private string EmitPattern(PatternNode pattern)
    {
        return pattern switch
        {
            WildcardPatternNode => "_",
            VariablePatternNode vp => $"var {SanitizeIdentifier(vp.Name)}",
            LiteralPatternNode lp => lp.Literal.Accept(this),
            SomePatternNode sp => $"{{ IsSome: true, Value: {EmitPattern(sp.InnerPattern)} }}",
            NonePatternNode => "{ IsNone: true }",
            OkPatternNode op => $"{{ IsOk: true, Value: {EmitPattern(op.InnerPattern)} }}",
            ErrPatternNode ep => $"{{ IsErr: true, Error: {EmitPattern(ep.InnerPattern)} }}",
            _ => "_"
        };
    }

    private string GetInferredTypeName(ExpressionNode expr)
    {
        return expr switch
        {
            IntLiteralNode => "int",
            FloatLiteralNode => "double",
            BoolLiteralNode => "bool",
            StringLiteralNode => "string",
            _ => "object"
        };
    }

    private static string MapTypeName(string opalType)
    {
        return opalType.ToUpperInvariant() switch
        {
            "VOID" => "void",
            "INT" => "int",
            "INT32" => "int",
            "INT64" => "long",
            "FLOAT" => "double",
            "FLOAT32" => "float",
            "FLOAT64" => "double",
            "BOOL" => "bool",
            "STRING" => "string",
            "STR" => "string",
            _ => opalType
        };
    }

    private static string SanitizeIdentifier(string name)
    {
        // Replace any characters that aren't valid in C# identifiers
        var sb = new StringBuilder();
        for (int i = 0; i < name.Length; i++)
        {
            var c = name[i];
            if (char.IsLetterOrDigit(c) || c == '_')
            {
                sb.Append(c);
            }
            else if (c == '.')
            {
                sb.Append('_');
            }
        }

        var result = sb.ToString();

        // Ensure identifier doesn't start with a digit
        if (result.Length > 0 && char.IsDigit(result[0]))
        {
            result = "_" + result;
        }

        // Handle reserved words
        return result switch
        {
            "class" or "struct" or "interface" or "enum" or
            "namespace" or "using" or "public" or "private" or
            "protected" or "internal" or "static" or "void" or
            "int" or "string" or "bool" or "float" or "double" or
            "return" or "if" or "else" or "for" or "while" or
            "do" or "switch" or "case" or "break" or "continue" or
            "new" or "this" or "base" or "null" or "true" or "false"
            => "@" + result,
            _ => result
        };
    }
}

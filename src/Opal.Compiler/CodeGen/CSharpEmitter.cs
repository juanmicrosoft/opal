using System.Text;
using Opal.Compiler.Ast;

namespace Opal.Compiler.CodeGen;

/// <summary>
/// Emits C# source code from an OPAL AST.
/// </summary>
public sealed class CSharpEmitter : IAstVisitor<string>
{
    private readonly StringBuilder _builder = new();
    private int _indentLevel;
    private string? _currentClassName;

    public string Emit(ModuleNode module)
    {
        _builder.Clear();
        _indentLevel = 0;

        var result = Visit(module);
        return result;
    }

    private void AppendLine(string line = "")
    {
        if (string.IsNullOrEmpty(line))
        {
            _builder.AppendLine();
        }
        else
        {
            _builder.Append(new string(' ', _indentLevel * 4));
            _builder.AppendLine(line);
        }
    }

    private void Indent() => _indentLevel++;
    private void Dedent() => _indentLevel--;

    public string Visit(ModuleNode node)
    {
        AppendLine("// <auto-generated>");
        AppendLine("// This code was generated by the OPAL compiler.");
        AppendLine("// Do not modify this file directly.");
        AppendLine("// </auto-generated>");
        AppendLine();

        // Always include System and Opal.Runtime
        var emittedUsings = new HashSet<string>(StringComparer.Ordinal) { "System", "Opal.Runtime" };
        AppendLine("using System;");
        AppendLine("using Opal.Runtime;");

        // Emit user-defined using directives
        foreach (var usingDirective in node.Usings)
        {
            var usingCode = Visit(usingDirective);
            if (!string.IsNullOrEmpty(usingCode))
            {
                // Track to avoid duplicates
                if (!emittedUsings.Contains(usingDirective.Namespace))
                {
                    AppendLine(usingCode);
                    emittedUsings.Add(usingDirective.Namespace);
                }
            }
        }
        AppendLine();

        var namespaceName = SanitizeIdentifier(node.Name);
        AppendLine($"namespace {namespaceName}");
        AppendLine("{");
        Indent();

        // Emit interfaces
        foreach (var iface in node.Interfaces)
        {
            Visit(iface);
            AppendLine();
        }

        // Emit classes
        foreach (var cls in node.Classes)
        {
            Visit(cls);
            AppendLine();
        }

        // Emit module-level functions in a static class
        if (node.Functions.Count > 0)
        {
            AppendLine($"public static class {namespaceName}Module");
            AppendLine("{");
            Indent();

            foreach (var function in node.Functions)
            {
                Visit(function);
                AppendLine();
            }

            Dedent();
            AppendLine("}");
        }

        Dedent();
        AppendLine("}");

        return _builder.ToString();
    }

    public string Visit(UsingDirectiveNode node)
    {
        if (node.IsStatic)
        {
            return $"using static {node.Namespace};";
        }
        else if (node.Alias != null)
        {
            return $"using {node.Alias} = {node.Namespace};";
        }
        else
        {
            return $"using {node.Namespace};";
        }
    }

    public string Visit(FunctionNode node)
    {
        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "private"
        };

        var returnType = node.Output?.TypeName ?? "void";
        var mappedReturnType = MapTypeName(returnType);
        var hasReturnValue = returnType.ToUpperInvariant() != "VOID";

        var parameters = string.Join(", ", node.Parameters.Select(p =>
            $"{MapTypeName(p.TypeName)} {SanitizeIdentifier(p.Name)}"));

        var methodName = SanitizeIdentifier(node.Name);

        // Build type parameters if present
        var typeParams = "";
        var whereClause = "";
        if (node.TypeParameters.Count > 0)
        {
            typeParams = "<" + string.Join(", ", node.TypeParameters.Select(tp => tp.Name)) + ">";

            // Build where clauses
            var whereClauses = new List<string>();
            foreach (var tp in node.TypeParameters)
            {
                if (tp.Constraints.Count > 0)
                {
                    var constraints = string.Join(", ", tp.Constraints.Select(c => EmitConstraint(c)));
                    whereClauses.Add($"where {tp.Name} : {constraints}");
                }
            }
            if (whereClauses.Count > 0)
            {
                whereClause = " " + string.Join(" ", whereClauses);
            }
        }

        // Check if this is the entry point
        var isMain = node.Name.Equals("Main", StringComparison.OrdinalIgnoreCase);
        var staticKeyword = isMain ? "static " : "static ";

        AppendLine($"{visibility} {staticKeyword}{mappedReturnType} {methodName}{typeParams}({parameters}){whereClause}");
        AppendLine("{");
        Indent();

        // Emit preconditions (REQUIRES)
        foreach (var requires in node.Preconditions)
        {
            var check = Visit(requires);
            AppendLine(check);
        }

        // If we have postconditions and a return value, we need special handling
        if (node.Postconditions.Count > 0 && hasReturnValue)
        {
            AppendLine($"{mappedReturnType} __result__ = default;");
            AppendLine();

            // Emit body statements, transforming return statements
            foreach (var statement in node.Body)
            {
                if (statement is ReturnStatementNode returnStmt && returnStmt.Expression != null)
                {
                    var expr = returnStmt.Expression.Accept(this);
                    AppendLine($"__result__ = {expr};");
                }
                else
                {
                    var stmtCode = statement.Accept(this);
                    AppendLine(stmtCode);
                }
            }

            AppendLine();
            // Emit postconditions (ENSURES)
            foreach (var ensures in node.Postconditions)
            {
                // Replace 'result' references with '__result__'
                var check = Visit(ensures).Replace("result", "__result__");
                AppendLine(check);
            }

            AppendLine("return __result__;");
        }
        else
        {
            // No postconditions or void return - emit body normally
            foreach (var statement in node.Body)
            {
                var stmtCode = statement.Accept(this);
                AppendLine(stmtCode);
            }

            // Emit postconditions for void functions (they can't reference 'result')
            foreach (var ensures in node.Postconditions)
            {
                var check = Visit(ensures);
                AppendLine(check);
            }
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(ParameterNode node)
    {
        return $"{MapTypeName(node.TypeName)} {SanitizeIdentifier(node.Name)}";
    }

    public string Visit(CallStatementNode node)
    {
        var target = node.Target;
        var args = string.Join(", ", node.Arguments.Select(a => a.Accept(this)));

        return $"{target}({args});";
    }

    public string Visit(ReturnStatementNode node)
    {
        if (node.Expression == null)
        {
            return "return;";
        }

        var expr = node.Expression.Accept(this);
        return $"return {expr};";
    }

    public string Visit(IntLiteralNode node)
    {
        return node.Value.ToString();
    }

    public string Visit(StringLiteralNode node)
    {
        // Escape the string for C#
        var escaped = node.Value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");

        return $"\"{escaped}\"";
    }

    public string Visit(BoolLiteralNode node)
    {
        return node.Value ? "true" : "false";
    }

    public string Visit(FloatLiteralNode node)
    {
        return node.Value.ToString(System.Globalization.CultureInfo.InvariantCulture);
    }

    public string Visit(ReferenceNode node)
    {
        return SanitizeIdentifier(node.Name);
    }

    // Phase 2: Control Flow

    public string Visit(ForStatementNode node)
    {
        var varName = SanitizeIdentifier(node.VariableName);
        var from = node.From.Accept(this);
        var to = node.To.Accept(this);
        var step = node.Step?.Accept(this) ?? "1";

        // Determine loop direction based on step (simple heuristic)
        var isPositiveStep = !step.StartsWith("-");
        var comparison = isPositiveStep ? "<=" : ">=";
        var increment = step == "1" ? $"{varName}++" : $"{varName} += {step}";

        AppendLine($"for (var {varName} = {from}; {varName} {comparison} {to}; {increment})");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            var stmtCode = stmt.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(WhileStatementNode node)
    {
        var condition = node.Condition.Accept(this);

        AppendLine($"while ({condition})");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            var stmtCode = stmt.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(IfStatementNode node)
    {
        var condition = node.Condition.Accept(this);

        AppendLine($"if ({condition})");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.ThenBody)
        {
            var stmtCode = stmt.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine("}");

        // Emit ELSEIF clauses
        foreach (var elseIf in node.ElseIfClauses)
        {
            var elseIfCondition = elseIf.Condition.Accept(this);
            AppendLine($"else if ({elseIfCondition})");
            AppendLine("{");
            Indent();

            foreach (var stmt in elseIf.Body)
            {
                var stmtCode = stmt.Accept(this);
                AppendLine(stmtCode);
            }

            Dedent();
            AppendLine("}");
        }

        // Emit ELSE clause
        if (node.ElseBody != null)
        {
            AppendLine("else");
            AppendLine("{");
            Indent();

            foreach (var stmt in node.ElseBody)
            {
                var stmtCode = stmt.Accept(this);
                AppendLine(stmtCode);
            }

            Dedent();
            AppendLine("}");
        }

        return "";
    }

    public string Visit(BindStatementNode node)
    {
        var varName = SanitizeIdentifier(node.Name);
        var typeName = node.TypeName != null ? MapTypeName(node.TypeName) : "var";

        if (node.Initializer != null)
        {
            var initExpr = node.Initializer.Accept(this);
            return $"{typeName} {varName} = {initExpr};";
        }

        // No initializer - need explicit type
        if (node.TypeName == null)
        {
            typeName = "int"; // Default to int
        }
        return $"{typeName} {varName} = default;";
    }

    public string Visit(BinaryOperationNode node)
    {
        var left = node.Left.Accept(this);
        var right = node.Right.Accept(this);

        // Special handling for Power operator (use Math.Pow)
        if (node.Operator == BinaryOperator.Power)
        {
            return $"Math.Pow({left}, {right})";
        }

        var op = node.Operator.ToCSharpOperator();
        return $"({left} {op} {right})";
    }

    public string Visit(UnaryOperationNode node)
    {
        var operand = node.Operand.Accept(this);
        var op = node.Operator.ToCSharpOperator();
        return $"({op}{operand})";
    }

    public string Visit(PrintStatementNode node)
    {
        var expr = node.Expression.Accept(this);
        var method = node.IsWriteLine ? "Console.WriteLine" : "Console.Write";
        return $"{method}({expr});";
    }

    // Phase 3: Type System

    public string Visit(RecordDefinitionNode node)
    {
        AppendLine($"public record {SanitizeIdentifier(node.Name)}(");
        Indent();

        for (int i = 0; i < node.Fields.Count; i++)
        {
            var field = node.Fields[i];
            var typeName = MapTypeName(field.TypeName);
            var fieldName = SanitizeIdentifier(field.Name);
            var comma = i < node.Fields.Count - 1 ? "," : "";
            AppendLine($"{typeName} {fieldName}{comma}");
        }

        Dedent();
        AppendLine(");");

        return "";
    }

    public string Visit(UnionTypeDefinitionNode node)
    {
        // Generate as abstract base class with derived classes for each variant
        var typeName = SanitizeIdentifier(node.Name);

        AppendLine($"public abstract record {typeName};");
        AppendLine();

        foreach (var variant in node.Variants)
        {
            var variantName = SanitizeIdentifier(variant.Name);
            if (variant.Fields.Count == 0)
            {
                AppendLine($"public sealed record {variantName}() : {typeName};");
            }
            else
            {
                var fields = string.Join(", ", variant.Fields.Select(f =>
                    $"{MapTypeName(f.TypeName)} {SanitizeIdentifier(f.Name)}"));
                AppendLine($"public sealed record {variantName}({fields}) : {typeName};");
            }
        }

        return "";
    }

    public string Visit(RecordCreationNode node)
    {
        var typeName = SanitizeIdentifier(node.TypeName);
        var fields = string.Join(", ", node.Fields.Select(f => f.Value.Accept(this)));
        return $"new {typeName}({fields})";
    }

    public string Visit(FieldAccessNode node)
    {
        var target = node.Target.Accept(this);
        var fieldName = SanitizeIdentifier(node.FieldName);
        return $"{target}.{fieldName}";
    }

    public string Visit(SomeExpressionNode node)
    {
        var value = node.Value.Accept(this);
        return $"Opal.Runtime.Option.Some({value})";
    }

    public string Visit(NoneExpressionNode node)
    {
        if (node.TypeName != null)
        {
            var typeName = MapTypeName(node.TypeName);
            return $"Opal.Runtime.Option<{typeName}>.None()";
        }
        return "Opal.Runtime.Option.None<object>()";
    }

    public string Visit(OkExpressionNode node)
    {
        var value = node.Value.Accept(this);
        return $"Opal.Runtime.Result.Ok<{GetInferredTypeName(node.Value)}, string>({value})";
    }

    public string Visit(ErrExpressionNode node)
    {
        var error = node.Error.Accept(this);
        return $"Opal.Runtime.Result.Err<object, {GetInferredTypeName(node.Error)}>({error})";
    }

    public string Visit(MatchExpressionNode node)
    {
        // Generate as switch expression
        var target = node.Target.Accept(this);
        var sb = new System.Text.StringBuilder();
        sb.Append($"{target} switch {{ ");

        for (int i = 0; i < node.Cases.Count; i++)
        {
            var matchCase = node.Cases[i];
            var pattern = EmitPattern(matchCase.Pattern);
            // For expression match, the body should yield a value
            // Take the last statement if it's a return, otherwise default
            var body = "default";
            if (matchCase.Body.Count > 0)
            {
                var lastStmt = matchCase.Body[^1];
                if (lastStmt is ReturnStatementNode ret && ret.Expression != null)
                {
                    body = ret.Expression.Accept(this);
                }
            }
            sb.Append($"{pattern} => {body}");
            if (i < node.Cases.Count - 1) sb.Append(", ");
        }

        sb.Append(" }");
        return sb.ToString();
    }

    public string Visit(MatchStatementNode node)
    {
        var target = node.Target.Accept(this);

        AppendLine($"switch ({target})");
        AppendLine("{");
        Indent();

        foreach (var matchCase in node.Cases)
        {
            var pattern = EmitPattern(matchCase.Pattern);
            AppendLine($"case {pattern}:");
            Indent();

            foreach (var stmt in matchCase.Body)
            {
                var stmtCode = stmt.Accept(this);
                AppendLine(stmtCode);
            }

            AppendLine("break;");
            Dedent();
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    private string EmitPattern(PatternNode pattern)
    {
        return pattern switch
        {
            WildcardPatternNode => "_",
            VariablePatternNode vp => $"var {SanitizeIdentifier(vp.Name)}",
            LiteralPatternNode lp => lp.Literal.Accept(this),
            SomePatternNode sp => $"{{ IsSome: true, Value: {EmitPattern(sp.InnerPattern)} }}",
            NonePatternNode => "{ IsNone: true }",
            OkPatternNode op => $"{{ IsOk: true, Value: {EmitPattern(op.InnerPattern)} }}",
            ErrPatternNode ep => $"{{ IsErr: true, Error: {EmitPattern(ep.InnerPattern)} }}",
            _ => "_"
        };
    }

    public string Visit(MatchCaseNode node)
    {
        var pattern = EmitPattern(node.Pattern);
        // For match statement context, case is emitted as part of switch
        return pattern;
    }

    public string Visit(WildcardPatternNode node) => "_";

    public string Visit(VariablePatternNode node) => $"var {SanitizeIdentifier(node.Name)}";

    public string Visit(LiteralPatternNode node) => node.Literal.Accept(this);

    public string Visit(SomePatternNode node)
        => $"{{ IsSome: true, Value: {node.InnerPattern.Accept(this)} }}";

    public string Visit(NonePatternNode node) => "{ IsNone: true }";

    public string Visit(OkPatternNode node)
        => $"{{ IsOk: true, Value: {node.InnerPattern.Accept(this)} }}";

    public string Visit(ErrPatternNode node)
        => $"{{ IsErr: true, Error: {node.InnerPattern.Accept(this)} }}";

    // Phase 4: Contracts

    public string Visit(RequiresNode node)
    {
        var condition = node.Condition.Accept(this);
        var message = node.Message != null
            ? $"\"{EscapeString(node.Message)}\""
            : $"\"Precondition failed: {EscapeString(condition)}\"";
        return $"if (!({condition})) throw new ArgumentException({message});";
    }

    public string Visit(EnsuresNode node)
    {
        var condition = node.Condition.Accept(this);
        var message = node.Message != null
            ? $"\"{EscapeString(node.Message)}\""
            : $"\"Postcondition failed: {EscapeString(condition)}\"";
        return $"if (!({condition})) throw new InvalidOperationException({message});";
    }

    public string Visit(InvariantNode node)
    {
        var condition = node.Condition.Accept(this);
        var message = node.Message != null
            ? $"\"{EscapeString(node.Message)}\""
            : $"\"Invariant violated: {EscapeString(condition)}\"";
        return $"if (!({condition})) throw new InvalidOperationException({message});";
    }

    private static string EscapeString(string s)
    {
        return s.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }

    // Phase 6: Arrays and Collections

    public string Visit(ArrayCreationNode node)
    {
        var elementType = MapTypeName(node.ElementType);
        var varName = SanitizeIdentifier(node.Name);

        if (node.Size != null)
        {
            // Sized array: int[] arr = new int[10];
            var size = node.Size.Accept(this);
            return $"{elementType}[] {varName} = new {elementType}[{size}];";
        }
        else if (node.Initializer.Count > 0)
        {
            // Initialized array: int[] arr = { 1, 2, 3 };
            var elements = string.Join(", ", node.Initializer.Select(e => e.Accept(this)));
            return $"{elementType}[] {varName} = {{ {elements} }};";
        }
        else
        {
            // Empty array
            return $"{elementType}[] {varName} = Array.Empty<{elementType}>();";
        }
    }

    public string Visit(ArrayAccessNode node)
    {
        var array = node.Array.Accept(this);
        var index = node.Index.Accept(this);
        return $"{array}[{index}]";
    }

    public string Visit(ArrayLengthNode node)
    {
        var array = node.Array.Accept(this);
        return $"{array}.Length";
    }

    public string Visit(ForeachStatementNode node)
    {
        var varType = MapTypeName(node.VariableType);
        var varName = SanitizeIdentifier(node.VariableName);
        var collection = node.Collection.Accept(this);

        AppendLine($"foreach ({varType} {varName} in {collection})");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            var stmtCode = stmt.Accept(this);
            AppendLine(stmtCode);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    // Phase 7: Generics

    public string Visit(TypeParameterNode node)
    {
        // Type parameters are handled in function/method signature emission
        return node.Name;
    }

    public string Visit(TypeConstraintNode node)
    {
        return EmitConstraint(node);
    }

    public string Visit(GenericTypeNode node)
    {
        var typeName = MapTypeName(node.TypeName);
        if (node.TypeArguments.Count == 0)
        {
            return typeName;
        }

        var typeArgs = string.Join(", ", node.TypeArguments.Select(MapTypeName));
        return $"{typeName}<{typeArgs}>";
    }

    private string EmitConstraint(TypeConstraintNode constraint)
    {
        return constraint.Kind switch
        {
            TypeConstraintKind.Class => "class",
            TypeConstraintKind.Struct => "struct",
            TypeConstraintKind.New => "new()",
            TypeConstraintKind.Interface => constraint.TypeName ?? "object",
            TypeConstraintKind.BaseClass => constraint.TypeName ?? "object",
            TypeConstraintKind.TypeName => MapTypeName(constraint.TypeName ?? "object"),
            _ => "object"
        };
    }

    // Phase 8: Classes, Interfaces, Inheritance

    public string Visit(InterfaceDefinitionNode node)
    {
        var name = SanitizeIdentifier(node.Name);
        var baseList = node.BaseInterfaces.Count > 0
            ? " : " + string.Join(", ", node.BaseInterfaces.Select(SanitizeIdentifier))
            : "";

        AppendLine($"public interface {name}{baseList}");
        AppendLine("{");
        Indent();

        foreach (var method in node.Methods)
        {
            Visit(method);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(MethodSignatureNode node)
    {
        var returnType = node.Output?.TypeName ?? "void";
        var mappedReturnType = MapTypeName(returnType);
        var methodName = SanitizeIdentifier(node.Name);

        var typeParams = "";
        if (node.TypeParameters.Count > 0)
        {
            typeParams = "<" + string.Join(", ", node.TypeParameters.Select(tp => tp.Name)) + ">";
        }

        var parameters = string.Join(", ", node.Parameters.Select(p =>
            $"{MapTypeName(p.TypeName)} {SanitizeIdentifier(p.Name)}"));

        AppendLine($"{mappedReturnType} {methodName}{typeParams}({parameters});");

        return "";
    }

    public string Visit(ClassDefinitionNode node)
    {
        var name = SanitizeIdentifier(node.Name);

        var modifiers = "public";
        if (node.IsAbstract) modifiers += " abstract";
        if (node.IsSealed) modifiers += " sealed";

        // Build type parameters
        var typeParams = "";
        var whereClause = "";
        if (node.TypeParameters.Count > 0)
        {
            typeParams = "<" + string.Join(", ", node.TypeParameters.Select(tp => tp.Name)) + ">";

            var whereClauses = new List<string>();
            foreach (var tp in node.TypeParameters)
            {
                if (tp.Constraints.Count > 0)
                {
                    var constraints = string.Join(", ", tp.Constraints.Select(c => EmitConstraint(c)));
                    whereClauses.Add($"where {tp.Name} : {constraints}");
                }
            }
            if (whereClauses.Count > 0)
            {
                whereClause = " " + string.Join(" ", whereClauses);
            }
        }

        // Build inheritance list
        var baseList = new List<string>();
        if (!string.IsNullOrEmpty(node.BaseClass))
        {
            baseList.Add(SanitizeIdentifier(node.BaseClass));
        }
        baseList.AddRange(node.ImplementedInterfaces.Select(SanitizeIdentifier));
        var inheritance = baseList.Count > 0 ? " : " + string.Join(", ", baseList) : "";

        AppendLine($"{modifiers} class {name}{typeParams}{inheritance}{whereClause}");
        AppendLine("{");
        Indent();

        // Set current class name for constructor emission
        _currentClassName = name;

        // Emit fields
        foreach (var field in node.Fields)
        {
            Visit(field);
        }

        // Emit properties
        foreach (var prop in node.Properties)
        {
            Visit(prop);
            AppendLine();
        }

        // Emit constructors
        foreach (var ctor in node.Constructors)
        {
            Visit(ctor);
            AppendLine();
        }

        // Emit methods
        foreach (var method in node.Methods)
        {
            Visit(method);
            AppendLine();
        }

        _currentClassName = null;

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(ClassFieldNode node)
    {
        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "private"
        };

        var typeName = MapTypeName(node.TypeName);
        var fieldName = SanitizeIdentifier(node.Name);

        if (node.DefaultValue != null)
        {
            var defaultVal = node.DefaultValue.Accept(this);
            AppendLine($"{visibility} {typeName} {fieldName} = {defaultVal};");
        }
        else
        {
            AppendLine($"{visibility} {typeName} {fieldName};");
        }

        return "";
    }

    public string Visit(MethodNode node)
    {
        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "private"
        };

        var modifiers = new List<string> { visibility };
        if (node.IsStatic) modifiers.Add("static");
        if (node.IsAbstract) modifiers.Add("abstract");
        else if (node.IsVirtual) modifiers.Add("virtual");
        if (node.IsOverride) modifiers.Add("override");
        if (node.IsSealed && node.IsOverride) modifiers.Add("sealed");

        var returnType = node.Output?.TypeName ?? "void";
        var mappedReturnType = MapTypeName(returnType);
        var hasReturnValue = returnType.ToUpperInvariant() != "VOID";
        var methodName = SanitizeIdentifier(node.Name);

        // Build type parameters
        var typeParams = "";
        var whereClause = "";
        if (node.TypeParameters.Count > 0)
        {
            typeParams = "<" + string.Join(", ", node.TypeParameters.Select(tp => tp.Name)) + ">";

            var whereClauses = new List<string>();
            foreach (var tp in node.TypeParameters)
            {
                if (tp.Constraints.Count > 0)
                {
                    var constraints = string.Join(", ", tp.Constraints.Select(c => EmitConstraint(c)));
                    whereClauses.Add($"where {tp.Name} : {constraints}");
                }
            }
            if (whereClauses.Count > 0)
            {
                whereClause = " " + string.Join(" ", whereClauses);
            }
        }

        var parameters = string.Join(", ", node.Parameters.Select(p =>
            $"{MapTypeName(p.TypeName)} {SanitizeIdentifier(p.Name)}"));

        // Abstract methods have no body
        if (node.IsAbstract)
        {
            AppendLine($"{string.Join(" ", modifiers)} {mappedReturnType} {methodName}{typeParams}({parameters}){whereClause};");
            return "";
        }

        AppendLine($"{string.Join(" ", modifiers)} {mappedReturnType} {methodName}{typeParams}({parameters}){whereClause}");
        AppendLine("{");
        Indent();

        // Emit preconditions
        foreach (var requires in node.Preconditions)
        {
            var check = Visit(requires);
            AppendLine(check);
        }

        // Handle postconditions similar to FunctionNode
        if (node.Postconditions.Count > 0 && hasReturnValue)
        {
            AppendLine($"{mappedReturnType} __result__ = default;");
            AppendLine();

            foreach (var statement in node.Body)
            {
                if (statement is ReturnStatementNode returnStmt && returnStmt.Expression != null)
                {
                    var expr = returnStmt.Expression.Accept(this);
                    AppendLine($"__result__ = {expr};");
                }
                else
                {
                    var stmtCode = statement.Accept(this);
                    AppendLine(stmtCode);
                }
            }

            AppendLine();
            foreach (var ensures in node.Postconditions)
            {
                var check = Visit(ensures).Replace("result", "__result__");
                AppendLine(check);
            }

            AppendLine("return __result__;");
        }
        else
        {
            foreach (var statement in node.Body)
            {
                var stmtCode = statement.Accept(this);
                AppendLine(stmtCode);
            }

            foreach (var ensures in node.Postconditions)
            {
                var check = Visit(ensures);
                AppendLine(check);
            }
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(NewExpressionNode node)
    {
        var typeName = SanitizeIdentifier(node.TypeName);
        if (node.TypeArguments.Count > 0)
        {
            typeName += "<" + string.Join(", ", node.TypeArguments.Select(MapTypeName)) + ">";
        }

        var args = string.Join(", ", node.Arguments.Select(a => a.Accept(this)));
        return $"new {typeName}({args})";
    }

    public string Visit(ThisExpressionNode node)
    {
        return "this";
    }

    public string Visit(BaseExpressionNode node)
    {
        return "base";
    }

    // Phase 9: Properties and Constructors

    public string Visit(PropertyNode node)
    {
        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "public"
        };

        var typeName = MapTypeName(node.TypeName);
        var propName = SanitizeIdentifier(node.Name);

        // Auto-property with default value
        if (node.IsAutoProperty)
        {
            if (node.DefaultValue != null)
            {
                var defaultVal = node.DefaultValue.Accept(this);
                AppendLine($"{visibility} {typeName} {propName} {{ get; set; }} = {defaultVal};");
            }
            else
            {
                AppendLine($"{visibility} {typeName} {propName} {{ get; set; }}");
            }
            return "";
        }

        // Property with accessors
        AppendLine($"{visibility} {typeName} {propName}");
        AppendLine("{");
        Indent();

        if (node.Getter != null)
        {
            Visit(node.Getter);
        }

        if (node.Setter != null)
        {
            Visit(node.Setter);
        }

        if (node.Initer != null)
        {
            Visit(node.Initer);
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(PropertyAccessorNode node)
    {
        var accessorKeyword = node.Kind switch
        {
            PropertyAccessorNode.AccessorKind.Get => "get",
            PropertyAccessorNode.AccessorKind.Set => "set",
            PropertyAccessorNode.AccessorKind.Init => "init",
            _ => "get"
        };

        var visibilityPrefix = node.Visibility switch
        {
            Visibility.Private => "private ",
            Visibility.Internal => "internal ",
            Visibility.Protected => "protected ",
            _ => ""
        };

        if (node.IsAutoImplemented)
        {
            AppendLine($"{visibilityPrefix}{accessorKeyword};");
        }
        else
        {
            AppendLine($"{visibilityPrefix}{accessorKeyword}");
            AppendLine("{");
            Indent();

            foreach (var pre in node.Preconditions)
            {
                AppendLine(Visit(pre));
            }

            foreach (var stmt in node.Body)
            {
                AppendLine(stmt.Accept(this));
            }

            Dedent();
            AppendLine("}");
        }

        return "";
    }

    public string Visit(ConstructorNode node)
    {
        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "public"
        };

        // Constructor name is the class name
        var ctorName = _currentClassName ?? "UnknownClass";
        var parameters = string.Join(", ", node.Parameters.Select(p =>
            $"{MapTypeName(p.TypeName)} {SanitizeIdentifier(p.Name)}"));

        var initializerStr = "";
        if (node.Initializer != null)
        {
            var initArgs = string.Join(", ", node.Initializer.Arguments.Select(a => a.Accept(this)));
            initializerStr = node.Initializer.IsBaseCall ? $" : base({initArgs})" : $" : this({initArgs})";
        }

        AppendLine($"{visibility} {ctorName}({parameters}){initializerStr}");
        AppendLine("{");
        Indent();

        foreach (var pre in node.Preconditions)
        {
            AppendLine(Visit(pre));
        }

        foreach (var stmt in node.Body)
        {
            AppendLine(stmt.Accept(this));
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(ConstructorInitializerNode node)
    {
        var args = string.Join(", ", node.Arguments.Select(a => a.Accept(this)));
        return node.IsBaseCall ? $"base({args})" : $"this({args})";
    }

    public string Visit(AssignmentStatementNode node)
    {
        var target = node.Target.Accept(this);
        var value = node.Value.Accept(this);
        return $"{target} = {value};";
    }

    // Phase 10: Try/Catch/Finally

    public string Visit(TryStatementNode node)
    {
        AppendLine("try");
        AppendLine("{");
        Indent();

        foreach (var stmt in node.TryBody)
        {
            AppendLine(stmt.Accept(this));
        }

        Dedent();
        AppendLine("}");

        foreach (var catchClause in node.CatchClauses)
        {
            Visit(catchClause);
        }

        if (node.FinallyBody != null)
        {
            AppendLine("finally");
            AppendLine("{");
            Indent();

            foreach (var stmt in node.FinallyBody)
            {
                AppendLine(stmt.Accept(this));
            }

            Dedent();
            AppendLine("}");
        }

        return "";
    }

    public string Visit(CatchClauseNode node)
    {
        var catchPart = "catch";
        if (node.ExceptionType != null)
        {
            var exType = SanitizeIdentifier(node.ExceptionType);
            if (node.VariableName != null)
            {
                var varName = SanitizeIdentifier(node.VariableName);
                catchPart = $"catch ({exType} {varName})";
            }
            else
            {
                catchPart = $"catch ({exType})";
            }
        }

        if (node.Filter != null)
        {
            var filter = node.Filter.Accept(this);
            catchPart += $" when ({filter})";
        }

        AppendLine(catchPart);
        AppendLine("{");
        Indent();

        foreach (var stmt in node.Body)
        {
            AppendLine(stmt.Accept(this));
        }

        Dedent();
        AppendLine("}");

        return "";
    }

    public string Visit(ThrowStatementNode node)
    {
        if (node.Exception != null)
        {
            var exception = node.Exception.Accept(this);
            return $"throw {exception};";
        }
        return "throw;";
    }

    public string Visit(RethrowStatementNode node)
    {
        return "throw;";
    }

    // Phase 11: Lambdas, Delegates, Events

    public string Visit(LambdaParameterNode node)
    {
        if (node.TypeName != null)
        {
            return $"{MapTypeName(node.TypeName)} {SanitizeIdentifier(node.Name)}";
        }
        return SanitizeIdentifier(node.Name);
    }

    public string Visit(LambdaExpressionNode node)
    {
        var async = node.IsAsync ? "async " : "";
        var parameters = node.Parameters.Count switch
        {
            0 => "()",
            1 when node.Parameters[0].TypeName == null => SanitizeIdentifier(node.Parameters[0].Name),
            _ => "(" + string.Join(", ", node.Parameters.Select(p => Visit(p))) + ")"
        };

        if (node.IsExpressionLambda && node.ExpressionBody != null)
        {
            var body = node.ExpressionBody.Accept(this);
            return $"{async}{parameters} => {body}";
        }
        else if (node.StatementBody != null && node.StatementBody.Count > 0)
        {
            var sb = new StringBuilder();
            sb.Append($"{async}{parameters} => {{\n");
            foreach (var stmt in node.StatementBody)
            {
                sb.Append($"    {stmt.Accept(this)}\n");
            }
            sb.Append("}");
            return sb.ToString();
        }

        return $"{async}{parameters} => default";
    }

    public string Visit(DelegateDefinitionNode node)
    {
        var name = SanitizeIdentifier(node.Name);
        var returnType = node.Output?.TypeName ?? "void";
        var mappedReturnType = MapTypeName(returnType);
        var parameters = string.Join(", ", node.Parameters.Select(p =>
            $"{MapTypeName(p.TypeName)} {SanitizeIdentifier(p.Name)}"));

        AppendLine($"public delegate {mappedReturnType} {name}({parameters});");
        return "";
    }

    public string Visit(EventDefinitionNode node)
    {
        var visibility = node.Visibility switch
        {
            Visibility.Public => "public",
            Visibility.Internal => "internal",
            Visibility.Private => "private",
            _ => "public"
        };

        var eventName = SanitizeIdentifier(node.Name);
        var delegateType = SanitizeIdentifier(node.DelegateType);

        AppendLine($"{visibility} event {delegateType} {eventName};");
        return "";
    }

    public string Visit(EventSubscribeNode node)
    {
        var @event = node.Event.Accept(this);
        var handler = node.Handler.Accept(this);
        return $"{@event} += {handler};";
    }

    public string Visit(EventUnsubscribeNode node)
    {
        var @event = node.Event.Accept(this);
        var handler = node.Handler.Accept(this);
        return $"{@event} -= {handler};";
    }

    // Phase 12: Async/Await

    public string Visit(AwaitExpressionNode node)
    {
        var awaited = node.Awaited.Accept(this);

        // Handle ConfigureAwait if specified
        if (node.ConfigureAwait.HasValue)
        {
            var configValue = node.ConfigureAwait.Value ? "true" : "false";
            return $"await {awaited}.ConfigureAwait({configValue})";
        }

        return $"await {awaited}";
    }

    // Phase 9: String Interpolation and Modern Operators

    public string Visit(InterpolatedStringNode node)
    {
        var sb = new StringBuilder();
        sb.Append("$\"");

        foreach (var part in node.Parts)
        {
            if (part is InterpolatedStringTextNode textPart)
            {
                // Escape quotes and braces in literal text
                var escaped = textPart.Text
                    .Replace("\\", "\\\\")
                    .Replace("\"", "\\\"")
                    .Replace("{", "{{")
                    .Replace("}", "}}");
                sb.Append(escaped);
            }
            else if (part is InterpolatedStringExpressionNode exprPart)
            {
                sb.Append("{");
                sb.Append(exprPart.Expression.Accept(this));
                sb.Append("}");
            }
        }

        sb.Append("\"");
        return sb.ToString();
    }

    public string Visit(InterpolatedStringTextNode node)
    {
        // This is typically only called standalone, not as part of interpolation
        return node.Text;
    }

    public string Visit(InterpolatedStringExpressionNode node)
    {
        // This is typically only called standalone, not as part of interpolation
        return node.Expression.Accept(this);
    }

    public string Visit(NullCoalesceNode node)
    {
        var left = node.Left.Accept(this);
        var right = node.Right.Accept(this);
        return $"{left} ?? {right}";
    }

    public string Visit(NullConditionalNode node)
    {
        var target = node.Target.Accept(this);
        return $"{target}?.{SanitizeIdentifier(node.MemberName)}";
    }

    public string Visit(RangeExpressionNode node)
    {
        var start = node.Start?.Accept(this) ?? "";
        var end = node.End?.Accept(this) ?? "";
        return $"{start}..{end}";
    }

    public string Visit(IndexFromEndNode node)
    {
        var offset = node.Offset.Accept(this);
        return $"^{offset}";
    }

    // Phase 10: Advanced Patterns

    public string Visit(WithExpressionNode node)
    {
        var target = node.Target.Accept(this);
        var assignments = string.Join(", ", node.Assignments.Select(a =>
            $"{SanitizeIdentifier(a.PropertyName)} = {a.Value.Accept(this)}"));
        return $"{target} with {{ {assignments} }}";
    }

    public string Visit(WithPropertyAssignmentNode node)
    {
        var value = node.Value.Accept(this);
        return $"{SanitizeIdentifier(node.PropertyName)} = {value}";
    }

    public string Visit(PositionalPatternNode node)
    {
        var patterns = string.Join(", ", node.Patterns.Select(p => p.Accept(this)));
        return $"{SanitizeIdentifier(node.TypeName)}({patterns})";
    }

    public string Visit(PropertyPatternNode node)
    {
        var matches = string.Join(", ", node.Matches.Select(m => m.Accept(this)));
        var typePart = string.IsNullOrEmpty(node.TypeName) ? "" : SanitizeIdentifier(node.TypeName) + " ";
        return $"{typePart}{{ {matches} }}";
    }

    public string Visit(PropertyMatchNode node)
    {
        var pattern = node.Pattern.Accept(this);
        return $"{SanitizeIdentifier(node.PropertyName)}: {pattern}";
    }

    public string Visit(RelationalPatternNode node)
    {
        var value = node.Value.Accept(this);
        var op = node.Operator.ToLowerInvariant() switch
        {
            "lt" => "<",
            "lte" => "<=",
            "gt" => ">",
            "gte" => ">=",
            "eq" => "",
            _ => node.Operator
        };
        return string.IsNullOrEmpty(op) ? value : $"{op} {value}";
    }

    public string Visit(ListPatternNode node)
    {
        var parts = new List<string>();
        foreach (var pattern in node.Patterns)
        {
            parts.Add(pattern.Accept(this));
        }
        if (node.SlicePattern != null)
        {
            parts.Add($"..{node.SlicePattern.Accept(this)}");
        }
        return $"[{string.Join(", ", parts)}]";
    }

    public string Visit(VarPatternNode node)
    {
        return $"var {SanitizeIdentifier(node.Name)}";
    }

    public string Visit(ConstantPatternNode node)
    {
        return node.Value.Accept(this);
    }

    private string GetInferredTypeName(ExpressionNode expr)
    {
        return expr switch
        {
            IntLiteralNode => "int",
            FloatLiteralNode => "double",
            BoolLiteralNode => "bool",
            StringLiteralNode => "string",
            _ => "object"
        };
    }

    private static string MapTypeName(string opalType)
    {
        return opalType.ToUpperInvariant() switch
        {
            "VOID" => "void",
            "INT" => "int",
            "INT32" => "int",
            "INT64" => "long",
            "FLOAT" => "double",
            "FLOAT32" => "float",
            "FLOAT64" => "double",
            "BOOL" => "bool",
            "STRING" => "string",
            "STR" => "string",
            _ => opalType
        };
    }

    private static string SanitizeIdentifier(string name)
    {
        // Replace any characters that aren't valid in C# identifiers
        var sb = new StringBuilder();
        for (int i = 0; i < name.Length; i++)
        {
            var c = name[i];
            if (char.IsLetterOrDigit(c) || c == '_')
            {
                sb.Append(c);
            }
            else if (c == '.')
            {
                sb.Append('_');
            }
        }

        var result = sb.ToString();

        // Ensure identifier doesn't start with a digit
        if (result.Length > 0 && char.IsDigit(result[0]))
        {
            result = "_" + result;
        }

        // Handle reserved words
        return result switch
        {
            "class" or "struct" or "interface" or "enum" or
            "namespace" or "using" or "public" or "private" or
            "protected" or "internal" or "static" or "void" or
            "int" or "string" or "bool" or "float" or "double" or
            "return" or "if" or "else" or "for" or "while" or
            "do" or "switch" or "case" or "break" or "continue" or
            "new" or "this" or "base" or "null" or "true" or "false"
            => "@" + result,
            _ => result
        };
    }
}

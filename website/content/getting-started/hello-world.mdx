---
title: "Hello World"
section: "getting-started"
order: 2
---


Calor is designed to be written by AI agents, not typed by hand. This guide shows you how to instruct an AI to generate Calor code.

---

## Prerequisites

Before starting, set up a Calor-enabled project:

```bash
dotnet new console -o HelloApp
cd HelloApp
calor init --ai claude
```

This creates:
- **CLAUDE.md** - Instructions telling Claude to write all new code in Calor
- **Hook configuration** - Automatically blocks `.cs` file creation, enforcing Calor-first
- **Skills** - Syntax reference Claude can consult when needed

---

## Your First Prompt

Open Claude Code in your project directory and simply ask:

```
Write a hello world program that prints "Hello from Calor!"
```

That's it. Claude automatically writes Calor code because:
1. CLAUDE.md instructs it to use Calor for all new code
2. The hook blocks any attempt to create `.cs` files

---

## What the AI Generates

Claude creates `Program.calr`:

```
§M{m001:HelloApp}
§F{f001:Main:pub}
  §O{void}
  §E{cw}
  §P "Hello from Calor!"
§/F{f001}
§/M{m001}
```

You don't need to understand every detail of this syntax - the AI handles it. But here's a quick breakdown:

| Line | What It Does |
|:-----|:-------------|
| `§M{m001:HelloApp}` | Declares a module (like a C# namespace) |
| `§F{f001:Main:pub}` | Declares a public function named `Main` |
| `§O{void}` | The function returns nothing |
| `§E{cw}` | The function writes to console (`cw` = console write) |
| `§P "Hello..."` | Prints the message |
| `§/F{f001}` `§/M{m001}` | Close the function and module |

---

## Build and Run

```bash
dotnet build
dotnet run
```

Output:
```
Hello from Calor!
```

---

## Generated C#

Behind the scenes, the Calor compiler transforms your code into C#:

```csharp
// <auto-generated>
// This file was generated by the Calor compiler.
// </auto-generated>

namespace HelloApp
{
    public static class Program
    {
        public static void Main()
        {
            System.Console.WriteLine("Hello from Calor!");
        }
    }
}
```

This file is placed in `obj/calor/` and compiled automatically by MSBuild.

---

## More Examples

### Function with Input

**Prompt:**
```
Write a greet function that takes a name parameter and prints a greeting.
```

**Claude generates:**

```
§M{m001:Greeter}
§F{f001:Greet:pub}
  §I{str:name}
  §O{void}
  §E{cw}
  §P (+ "Hello, " name "!")
§/F{f001}
§/M{m001}
```

### Function with Return Value

**Prompt:**
```
Write a function that adds two integers and returns the result.
```

**Claude generates:**

```
§M{m001:Math}
§F{f001:Add:pub}
  §I{i32:a}
  §I{i32:b}
  §O{i32}
  §R (+ a b)
§/F{f001}
§/M{m001}
```

### Function with Contracts

**Prompt:**
```
Write a divide function that takes two integers a and b,
requires b is not zero, and returns a / b.
```

**Claude generates:**

```
§M{m001:SafeMath}
§F{f001:Divide:pub}
  §I{i32:a}
  §I{i32:b}
  §O{i32}
  §Q (!= b 0)
  §R (/ a b)
§/F{f001}
§/M{m001}
```

The `§Q (!= b 0)` is a **precondition** - the compiler generates runtime checks to enforce this contract.

---

## Why AI-Generated?

Calor's syntax is optimized for AI agents:

1. **Unambiguous structure** - Every block has explicit open/close tags with IDs, eliminating brace-matching errors
2. **Explicit contracts** - Preconditions and postconditions are first-class, not comments
3. **Declared effects** - The AI must declare what a function does (console, network, database)
4. **Lisp-style expressions** - `(+ a b)` is unambiguous; no operator precedence confusion

You describe *what* you want; the AI handles the *how*.

---

## Next Steps

- [Claude Integration](/getting-started/claude-integration/) - Deep dive into Claude Code workflow
- [Syntax Reference](/syntax-reference/) - Complete language reference (for understanding AI output)

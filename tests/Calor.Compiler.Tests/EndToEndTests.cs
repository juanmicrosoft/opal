using Calor.Compiler.Diagnostics;
using Calor.Compiler.Parsing;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;

namespace Calor.Compiler.Tests;

public class EndToEndTests
{
    [Fact]
    public void Compile_HelloWorld_GeneratesValidCSharp()
    {
        var source = """
            §M{m001:Hello}
            §F{f001:Main:pub}
              §O{void}
              §E{cw}
              §C{Console.WriteLine}
                §A "Hello from Calor!"
              §/C
            §/F{f001}
            §/M{m001}
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors);
        Assert.NotEmpty(result.GeneratedCode);

        // Verify generated code structure
        Assert.Contains("namespace Hello", result.GeneratedCode);
        Assert.Contains("public static class HelloModule", result.GeneratedCode);
        Assert.Contains("public static void Main()", result.GeneratedCode);
        Assert.Contains("Console.WriteLine(\"Hello from Calor!\")", result.GeneratedCode);
    }

    [Fact]
    public void Compile_WithParameters_GeneratesCorrectSignature()
    {
        var source = """
            §M{m001:Math}
            §F{f001:Add:pub}
              §I{i32:a}
              §I{i32:b}
              §O{i32}
              §R 0
            §/F{f001}
            §/M{m001}
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors);
        Assert.Contains("public static int Add(int a, int b)", result.GeneratedCode);
        Assert.Contains("return 0;", result.GeneratedCode);
    }

    [Fact]
    public void Compile_WithStringEscapes_GeneratesCorrectLiteral()
    {
        var source = """
            §M{m001:Test}
            §F{f001:Main:pub}
              §O{void}
              §E{cw}
              §C{Console.WriteLine}
                §A "Line1\nLine2"
              §/C
            §/F{f001}
            §/M{m001}
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors);
        Assert.Contains("Console.WriteLine(\"Line1\\nLine2\")", result.GeneratedCode);
    }

    [Fact]
    public void Compile_MismatchedId_ReturnsErrors()
    {
        var source = """
            §M{m001:Test}
            §/M{m999}
            """;

        var result = Program.Compile(source);

        Assert.True(result.HasErrors);
        Assert.Contains(result.Diagnostics, d => d.Code == "Calor0101");
    }

    [Fact]
    public void Compile_GeneratesAutoGeneratedHeader()
    {
        var source = """
            §M{m001:Test}
            §/M{m001}
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors);
        Assert.Contains("<auto-generated>", result.GeneratedCode);
        Assert.Contains("Calor compiler", result.GeneratedCode);
    }

    [Fact]
    public void Compile_MultipleFunctions_GeneratesAll()
    {
        var source = """
            §M{m001:Test}
            §F{f001:Foo:pub}
              §O{void}
            §/F{f001}
            §F{f002:Bar:pri}
              §O{void}
            §/F{f002}
            §/M{m001}
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors);
        Assert.Contains("public static void Foo()", result.GeneratedCode);
        Assert.Contains("private static void Bar()", result.GeneratedCode);
    }

    [Fact]
    public void Compile_BoolLiteral_GeneratesCorrectValue()
    {
        var source = """
            §M{m001:Test}
            §F{f001:IsEnabled:pub}
              §O{bool}
              §R true
            §/F{f001}
            §/M{m001}
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors);
        Assert.Contains("return true;", result.GeneratedCode);
    }

    [Fact]
    public void Compile_FloatLiteral_GeneratesCorrectValue()
    {
        var source = """
            §M{m001:Test}
            §F{f001:GetPi:pub}
              §O{f64}
              §R 3.14159
            §/F{f001}
            §/M{m001}
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors);
        Assert.Contains("return 3.14159;", result.GeneratedCode);
    }

    [Fact]
    public void Compile_InternalVisibility_GeneratesCorrectModifier()
    {
        var source = """
            §M{m001:Test}
            §F{f001:Helper:int}
              §O{void}
            §/F{f001}
            §/M{m001}
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors);
        Assert.Contains("internal static void Helper()", result.GeneratedCode);
    }

    [Fact]
    public void Compile_LispExpressions_GeneratesCorrectCode()
    {
        // Test: (== (% i 15) 0) should generate ((i % 15) == 0)
        var source = """
            §M{m001:Test}
            §F{f001:Check:pub}
              §I{i32:i}
              §O{bool}
              §BODY
                §R (== (% i 15) 0)
              §END_BODY
            §/F{f001}
            §/M{m001}
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors, string.Join("\n", result.Diagnostics.Select(d => d.Message)));
        Assert.Contains("((i % 15) == 0)", result.GeneratedCode);
    }

    [Fact]
    public void Compile_PrintAlias_GeneratesConsoleWriteLine()
    {
        var source = """
            §M{m001:Test}
            §F{f001:Main:pub}
              §O{void}
              §E{cw}
              §BODY
                §P "Hello!"
              §END_BODY
            §/F{f001}
            §/M{m001}
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors, string.Join("\n", result.Diagnostics.Select(d => d.Message)));
        Assert.Contains("Console.WriteLine(\"Hello!\")", result.GeneratedCode);
    }

    [Fact]
    public void Compile_ImplicitClosing_GeneratesCorrectCall()
    {
        var source = """
            §M{m001:Test}
            §F{f001:Main:pub}
              §O{void}
              §E{cw}
              §BODY
                §C{Console.WriteLine} "Implicit close"
              §END_BODY
            §/F{f001}
            §/M{m001}
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors, string.Join("\n", result.Diagnostics.Select(d => d.Message)));
        Assert.Contains("Console.WriteLine(\"Implicit close\")", result.GeneratedCode);
    }

    [Fact]
    public void Compile_UnaryNot_GeneratesCorrectCode()
    {
        var source = """
            §M{m001:Test}
            §F{f001:Negate:pub}
              §I{bool:flag}
              §O{bool}
              §BODY
                §R (! flag)
              §END_BODY
            §/F{f001}
            §/M{m001}
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors, string.Join("\n", result.Diagnostics.Select(d => d.Message)));
        Assert.Contains("(!flag)", result.GeneratedCode);
    }

    [Fact]
    public void Compile_PrintWithLispExpression_GeneratesCorrectCode()
    {
        var source = """
            §M{m001:Test}
            §F{f001:Main:pub}
              §I{i32:x}
              §O{void}
              §E{cw}
              §BODY
                §P (+ x 10)
              §END_BODY
            §/F{f001}
            §/M{m001}
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors, string.Join("\n", result.Diagnostics.Select(d => d.Message)));
        Assert.Contains("Console.WriteLine((x + 10))", result.GeneratedCode);
    }

    [Fact]
    public void Compile_ChainedOperators_GeneratesCorrectCode()
    {
        // (+ a b c) should generate ((a + b) + c)
        var source = """
            §M{m001:Test}
            §F{f001:Sum3:pub}
              §I{i32:a}
              §I{i32:b}
              §I{i32:c}
              §O{i32}
              §BODY
                §R (+ a b c)
              §END_BODY
            §/F{f001}
            §/M{m001}
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors, string.Join("\n", result.Diagnostics.Select(d => d.Message)));
        // The generated code should chain additions
        Assert.Contains("a + b", result.GeneratedCode);
        Assert.Contains("+ c", result.GeneratedCode);
    }

    [Fact]
    public void ValidateCodegen_ValidProgram_NoRoslynParseErrors()
    {
        var source = """
            §M{m001:Hello}
            §F{f001:Main:pub}
              §O{void}
              §E{cw}
              §P "Hello"
            §/F{f001}
            §/M{m001}
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors);
        Assert.NotEmpty(result.GeneratedCode);

        // Validate generated C# is syntactically valid (same as --validate-codegen)
        var tree = CSharpSyntaxTree.ParseText(result.GeneratedCode);
        var roslynErrors = tree.GetDiagnostics()
            .Where(d => d.Severity == Microsoft.CodeAnalysis.DiagnosticSeverity.Error)
            .ToList();

        Assert.Empty(roslynErrors);
    }

    [Fact]
    public void ValidateCodegen_InvalidCSharp_ProducesCalor1000Diagnostic()
    {
        // Simulate what --validate-codegen does: parse invalid C# and report Calor1000
        var invalidCSharp = "public class { }"; // missing class name

        var diagnostics = new DiagnosticBag();
        var tree = CSharpSyntaxTree.ParseText(invalidCSharp);
        foreach (var roslynDiag in tree.GetDiagnostics())
        {
            if (roslynDiag.Severity == Microsoft.CodeAnalysis.DiagnosticSeverity.Error)
            {
                var lineSpan = roslynDiag.Location.GetLineSpan();
                var span = new TextSpan(
                    0,
                    roslynDiag.Location.SourceSpan.Length,
                    lineSpan.StartLinePosition.Line + 1,
                    lineSpan.StartLinePosition.Character + 1);
                diagnostics.Report(
                    span,
                    DiagnosticCode.CodeGenSyntaxError,
                    $"Generated C# syntax error: {roslynDiag.GetMessage()}",
                    DiagnosticSeverity.Warning);
            }
        }

        // Should have at least one Calor1000 warning
        Assert.Contains(diagnostics, d => d.Code == DiagnosticCode.CodeGenSyntaxError);
        // Should be warnings, not errors
        Assert.DoesNotContain(diagnostics, d => d.Code == DiagnosticCode.CodeGenSyntaxError && d.IsError);
    }
}

{
  "version": "1.0",
  "description": "Calor vs C# evaluation benchmarks for AI coding agent effectiveness",
  "benchmarks": [
    {
      "id": "001",
      "name": "HelloWorld",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/HelloWorld.calr",
      "csharpFile": "TokenEconomics/HelloWorld.cs",
      "level": 1,
      "features": ["module", "function", "console_write", "effects"],
      "notes": "Simple hello world program - baseline comparison",
      "expectedAdvantage": 1.8
    },
    {
      "id": "002",
      "name": "Calculator",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/Calculator.calr",
      "csharpFile": "TokenEconomics/Calculator.cs",
      "level": 2,
      "features": ["module", "function", "parameters", "return_type", "arithmetic"],
      "notes": "Basic arithmetic operations with multiple functions"
    },
    {
      "id": "003",
      "name": "FizzBuzz",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/FizzBuzz.calr",
      "csharpFile": "TokenEconomics/FizzBuzz.cs",
      "level": 2,
      "features": ["module", "function", "conditional", "loop", "modulo"],
      "notes": "Classic FizzBuzz implementation"
    },
    {
      "id": "004",
      "name": "Factorial",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/Factorial.calr",
      "csharpFile": "TokenEconomics/Factorial.cs",
      "level": 2,
      "features": ["module", "function", "recursion", "conditional"],
      "notes": "Recursive factorial calculation"
    },
    {
      "id": "005",
      "name": "Fibonacci",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/Fibonacci.calr",
      "csharpFile": "TokenEconomics/Fibonacci.cs",
      "level": 2,
      "features": ["module", "function", "recursion", "conditional"],
      "notes": "Fibonacci sequence generator"
    },
    {
      "id": "006",
      "name": "ContractedDivide",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/ContractedDivide.calr",
      "csharpFile": "TokenEconomics/ContractedDivide.cs",
      "level": 3,
      "features": ["module", "function", "contracts", "requires", "ensures"],
      "notes": "Division with contract-based validation"
    },
    {
      "id": "007",
      "name": "StringUtils",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/StringUtils.calr",
      "csharpFile": "TokenEconomics/StringUtils.cs",
      "level": 2,
      "features": ["module", "function", "string_operations", "multiple_methods"],
      "notes": "String utility functions"
    },
    {
      "id": "008",
      "name": "MathOperations",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/MathOperations.calr",
      "csharpFile": "TokenEconomics/MathOperations.cs",
      "level": 3,
      "features": ["module", "function", "contracts", "effects", "pure"],
      "notes": "Math operations with purity effects"
    },
    {
      "id": "009",
      "name": "ArraySum",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/ArraySum.calr",
      "csharpFile": "TokenEconomics/ArraySum.cs",
      "level": 2,
      "features": ["module", "function", "array", "loop"],
      "notes": "Array summation"
    },
    {
      "id": "010",
      "name": "MaxValue",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/MaxValue.calr",
      "csharpFile": "TokenEconomics/MaxValue.cs",
      "level": 2,
      "features": ["module", "function", "array", "loop", "conditional"],
      "notes": "Find maximum value in array"
    },
    {
      "id": "011",
      "name": "IsPrime",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/IsPrime.calr",
      "csharpFile": "TokenEconomics/IsPrime.cs",
      "level": 3,
      "features": ["module", "function", "loop", "conditional", "contracts"],
      "notes": "Prime number checker"
    },
    {
      "id": "012",
      "name": "BinarySearch",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/BinarySearch.calr",
      "csharpFile": "TokenEconomics/BinarySearch.cs",
      "level": 3,
      "features": ["module", "function", "array", "loop", "algorithm"],
      "notes": "Binary search implementation"
    },
    {
      "id": "013",
      "name": "TemperatureConverter",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/TemperatureConverter.calr",
      "csharpFile": "TokenEconomics/TemperatureConverter.cs",
      "level": 1,
      "features": ["module", "function", "arithmetic", "multiple_methods"],
      "notes": "Temperature unit conversions"
    },
    {
      "id": "014",
      "name": "LeapYear",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/LeapYear.calr",
      "csharpFile": "TokenEconomics/LeapYear.cs",
      "level": 2,
      "features": ["module", "function", "conditional", "boolean"],
      "notes": "Leap year checker"
    },
    {
      "id": "015",
      "name": "GCD",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/GCD.calr",
      "csharpFile": "TokenEconomics/GCD.cs",
      "level": 2,
      "features": ["module", "function", "recursion", "algorithm"],
      "notes": "Greatest common divisor (Euclidean algorithm)"
    },
    {
      "id": "016",
      "name": "ReverseString",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/ReverseString.calr",
      "csharpFile": "TokenEconomics/ReverseString.cs",
      "level": 2,
      "features": ["module", "function", "string_operations", "loop"],
      "notes": "String reversal"
    },
    {
      "id": "017",
      "name": "CountVowels",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/CountVowels.calr",
      "csharpFile": "TokenEconomics/CountVowels.cs",
      "level": 2,
      "features": ["module", "function", "string_operations", "loop", "conditional"],
      "notes": "Count vowels in string"
    },
    {
      "id": "018",
      "name": "Palindrome",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/Palindrome.calr",
      "csharpFile": "TokenEconomics/Palindrome.cs",
      "level": 2,
      "features": ["module", "function", "string_operations", "loop", "boolean"],
      "notes": "Palindrome checker"
    },
    {
      "id": "019",
      "name": "Power",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/Power.calr",
      "csharpFile": "TokenEconomics/Power.cs",
      "level": 2,
      "features": ["module", "function", "recursion", "contracts"],
      "notes": "Power function with contracts"
    },
    {
      "id": "020",
      "name": "Clamp",
      "category": "TokenEconomics",
      "calorFile": "TokenEconomics/Clamp.calr",
      "csharpFile": "TokenEconomics/Clamp.cs",
      "level": 2,
      "features": ["module", "function", "conditional", "contracts", "ensures"],
      "notes": "Value clamping with postconditions"
    },
    {
      "id": "021",
      "name": "Stack",
      "category": "DataStructures",
      "calorFile": "DataStructures/Stack.calr",
      "csharpFile": "DataStructures/Stack.cs",
      "level": 3,
      "features": ["module", "function", "state", "contracts", "effects"],
      "notes": "Stack data structure with push, pop, peek operations"
    },
    {
      "id": "022",
      "name": "Queue",
      "category": "DataStructures",
      "calorFile": "DataStructures/Queue.calr",
      "csharpFile": "DataStructures/Queue.cs",
      "level": 3,
      "features": ["module", "function", "state", "contracts", "effects"],
      "notes": "Queue data structure with enqueue, dequeue operations"
    },
    {
      "id": "023",
      "name": "LinkedList",
      "category": "DataStructures",
      "calorFile": "DataStructures/LinkedList.calr",
      "csharpFile": "DataStructures/LinkedList.cs",
      "level": 4,
      "features": ["module", "function", "state", "contracts", "nested_types", "optional"],
      "notes": "Singly linked list with add/remove operations"
    },
    {
      "id": "024",
      "name": "BinaryTree",
      "category": "DataStructures",
      "calorFile": "DataStructures/BinaryTree.calr",
      "csharpFile": "DataStructures/BinaryTree.cs",
      "level": 4,
      "features": ["module", "function", "recursion", "state", "contracts", "tree"],
      "notes": "Binary search tree with insert and search"
    },
    {
      "id": "025",
      "name": "Singleton",
      "category": "DesignPatterns",
      "calorFile": "DesignPatterns/Singleton.calr",
      "csharpFile": "DesignPatterns/Singleton.cs",
      "level": 2,
      "features": ["module", "function", "state", "contracts", "design_pattern"],
      "notes": "Singleton pattern implementation"
    },
    {
      "id": "026",
      "name": "Factory",
      "category": "DesignPatterns",
      "calorFile": "DesignPatterns/Factory.calr",
      "csharpFile": "DesignPatterns/Factory.cs",
      "level": 3,
      "features": ["module", "function", "contracts", "polymorphism", "design_pattern"],
      "notes": "Factory pattern for shape creation"
    },
    {
      "id": "027",
      "name": "ShoppingCart",
      "category": "DomainProblems",
      "calorFile": "DomainProblems/ShoppingCart.calr",
      "csharpFile": "DomainProblems/ShoppingCart.cs",
      "level": 4,
      "features": ["module", "function", "state", "contracts", "domain_logic", "business_rules"],
      "notes": "Shopping cart with add/remove items and tax calculation"
    },
    {
      "id": "028",
      "name": "QuickSort",
      "category": "ComplexAlgorithms",
      "calorFile": "ComplexAlgorithms/QuickSort.calr",
      "csharpFile": "ComplexAlgorithms/QuickSort.cs",
      "level": 4,
      "features": ["module", "function", "recursion", "contracts", "algorithm", "in_place"],
      "notes": "QuickSort algorithm with partition"
    },
    {
      "id": "cv001",
      "name": "ProvableContracts",
      "category": "ContractVerification",
      "calorFile": "ContractVerification/ProvableContracts.calr",
      "csharpFile": "ContractVerification/ProvableContracts.cs",
      "level": 2,
      "features": ["contracts", "z3", "verification", "ensures"],
      "notes": "Functions with provable postconditions"
    },
    {
      "id": "cv002",
      "name": "BuggyContracts",
      "category": "ContractVerification",
      "calorFile": "ContractVerification/BuggyContracts.calr",
      "csharpFile": "ContractVerification/BuggyContracts.cs",
      "level": 2,
      "features": ["contracts", "z3", "verification", "disproven"],
      "notes": "Functions with provably violated postconditions"
    },
    {
      "id": "cv003",
      "name": "MixedContracts",
      "category": "ContractVerification",
      "calorFile": "ContractVerification/MixedContracts.calr",
      "csharpFile": "ContractVerification/MixedContracts.cs",
      "level": 3,
      "features": ["contracts", "z3", "verification", "mixed"],
      "notes": "Mix of provable and unprovable contracts"
    },
    {
      "id": "cv004",
      "name": "OverflowUnsafe",
      "category": "ContractVerification",
      "calorFile": "ContractVerification/OverflowUnsafe.calr",
      "csharpFile": "ContractVerification/OverflowUnsafe.cs",
      "level": 3,
      "features": ["contracts", "z3", "verification", "overflow", "bit-vectors", "disproven"],
      "notes": "Contracts that must be DISPROVEN due to integer overflow (validates bit-vector soundness)"
    },
    {
      "id": "cv005",
      "name": "OverflowSafe",
      "category": "ContractVerification",
      "calorFile": "ContractVerification/OverflowSafe.calr",
      "csharpFile": "ContractVerification/OverflowSafe.cs",
      "level": 3,
      "features": ["contracts", "z3", "verification", "overflow", "bit-vectors", "proven"],
      "notes": "Contracts with proper bounds that CAN be proven (no overflow possible)"
    },
    {
      "id": "cv006",
      "name": "StringContracts",
      "category": "ContractVerification",
      "calorFile": "ContractVerification/StringContracts.calr",
      "csharpFile": "ContractVerification/StringContracts.cs",
      "level": 3,
      "features": ["contracts", "z3", "verification", "strings", "string-theory"],
      "notes": "String operation contracts using Z3 string theory (length, contains, startswith, etc.)"
    },
    {
      "id": "cv007",
      "name": "ArrayContracts",
      "category": "ContractVerification",
      "calorFile": "ContractVerification/ArrayContracts.calr",
      "csharpFile": "ContractVerification/ArrayContracts.cs",
      "level": 3,
      "features": ["contracts", "z3", "verification", "arrays", "bounds-checking"],
      "notes": "Array index and bounds contracts (valid index, safe ranges, binary search invariants)"
    },
    {
      "id": "es001",
      "name": "CorrectEffects",
      "category": "EffectSoundness",
      "calorFile": "EffectSoundness/CorrectEffects.calr",
      "csharpFile": "EffectSoundness/CorrectEffects.cs",
      "level": 2,
      "features": ["effects", "enforcement", "sound"],
      "notes": "Functions with correctly declared effects"
    },
    {
      "id": "es002",
      "name": "MissingEffects",
      "category": "EffectSoundness",
      "calorFile": "EffectSoundness/MissingEffects.calr",
      "csharpFile": "EffectSoundness/MissingEffects.cs",
      "level": 2,
      "features": ["effects", "enforcement", "missing"],
      "notes": "Functions with undeclared effects"
    },
    {
      "id": "es003",
      "name": "HiddenNetworkEffect",
      "category": "EffectSoundness",
      "calorFile": "EffectSoundness/HiddenNetworkEffect.calr",
      "csharpFile": "EffectSoundness/HiddenNetworkEffect.cs",
      "level": 3,
      "features": ["effects", "enforcement", "transitive"],
      "notes": "Effect leakage through transitive calls"
    },
    {
      "id": "ie001",
      "name": "BclCoverage",
      "category": "InteropEffectCoverage",
      "calorFile": "InteropEffectCoverage/BclCoverage.calr",
      "csharpFile": "InteropEffectCoverage/BclCoverage.cs",
      "level": 2,
      "features": ["effects", "manifest", "bcl", "interop"],
      "notes": "Common BCL methods with effect annotations"
    },
    {
      "id": "ie002",
      "name": "PureFunctions",
      "category": "InteropEffectCoverage",
      "calorFile": "InteropEffectCoverage/PureFunctions.calr",
      "csharpFile": "InteropEffectCoverage/PureFunctions.cs",
      "level": 1,
      "features": ["effects", "manifest", "pure"],
      "notes": "Pure BCL methods that should resolve cleanly"
    }
  ],
  "comprehensionQuestions": {
    "003": [
      {
        "id": "q1",
        "question": "What does this function return for input 15?",
        "answer": "FizzBuzz",
        "category": "behavior",
        "difficulty": 1
      },
      {
        "id": "q2",
        "question": "What are the loop bounds?",
        "answer": "1 to n inclusive",
        "category": "structure",
        "difficulty": 1
      },
      {
        "id": "q3",
        "question": "In what order are divisibility checks performed?",
        "answer": "First checks if divisible by both 3 and 5, then by 3 alone, then by 5 alone",
        "category": "semantics",
        "difficulty": 2
      }
    ],
    "006": [
      {
        "id": "q1",
        "question": "What precondition must be satisfied to call Divide?",
        "answer": "The divisor (b) must not be zero",
        "category": "contracts",
        "difficulty": 1
      },
      {
        "id": "q2",
        "question": "What does the ensures clause guarantee?",
        "answer": "The result equals the quotient of a divided by b",
        "category": "contracts",
        "difficulty": 2
      }
    ]
  },
  "editTasks": [
    {
      "id": "edit001",
      "description": "Add validation to reject negative numbers in Calculator.Add",
      "calorBefore": "TokenEconomics/Calculator.calr",
      "calorAfter": "EditPrecision/Calculator_validated.calr",
      "csharpBefore": "TokenEconomics/Calculator.cs",
      "csharpAfter": "EditPrecision/Calculator_validated.cs",
      "category": "add_validation",
      "level": 2
    }
  ],
  "bugScenarios": [
    {
      "id": "bug001",
      "description": "Off-by-one error in loop bounds",
      "category": "bounds_check",
      "calorBuggy": "ErrorDetection/ArraySum_buggy.calr",
      "calorFixed": "TokenEconomics/ArraySum.calr",
      "csharpBuggy": "ErrorDetection/ArraySum_buggy.cs",
      "csharpFixed": "TokenEconomics/ArraySum.cs",
      "expectedError": "Array index out of bounds",
      "level": 2
    },
    {
      "id": "bug002",
      "description": "Division by zero possible",
      "category": "contract_violation",
      "calorBuggy": "ErrorDetection/Divide_buggy.calr",
      "calorFixed": "TokenEconomics/ContractedDivide.calr",
      "csharpBuggy": "ErrorDetection/Divide_buggy.cs",
      "csharpFixed": "TokenEconomics/ContractedDivide.cs",
      "expectedError": "Division by zero",
      "level": 2
    }
  ]
}

using Xunit;

namespace Opal.Compiler.Tests;

public class EndToEndTests
{
    [Fact]
    public void Compile_HelloWorld_GeneratesValidCSharp()
    {
        var source = """
            §MODULE[id=m001][name=Hello]
            §FUNC[id=f001][name=Main][visibility=public]
              §OUT[type=VOID]
              §EFFECTS[io=console_write]
              §BODY
                §CALL[target=Console.WriteLine][fallible=false]
                  §ARG STR:"Hello from OPAL!"
                §END_CALL
              §END_BODY
            §END_FUNC[id=f001]
            §END_MODULE[id=m001]
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors);
        Assert.NotEmpty(result.GeneratedCode);

        // Verify generated code structure
        Assert.Contains("namespace Hello", result.GeneratedCode);
        Assert.Contains("public static class HelloModule", result.GeneratedCode);
        Assert.Contains("public static void Main()", result.GeneratedCode);
        Assert.Contains("Console.WriteLine(\"Hello from OPAL!\")", result.GeneratedCode);
    }

    [Fact]
    public void Compile_WithParameters_GeneratesCorrectSignature()
    {
        var source = """
            §MODULE[id=m001][name=Math]
            §FUNC[id=f001][name=Add][visibility=public]
              §IN[name=a][type=INT]
              §IN[name=b][type=INT]
              §OUT[type=INT]
              §BODY
                §RETURN INT:0
              §END_BODY
            §END_FUNC[id=f001]
            §END_MODULE[id=m001]
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors);
        Assert.Contains("public static int Add(int a, int b)", result.GeneratedCode);
        Assert.Contains("return 0;", result.GeneratedCode);
    }

    [Fact]
    public void Compile_WithStringEscapes_GeneratesCorrectLiteral()
    {
        var source = """
            §MODULE[id=m001][name=Test]
            §FUNC[id=f001][name=Main][visibility=public]
              §OUT[type=VOID]
              §BODY
                §CALL[target=Console.WriteLine][fallible=false]
                  §ARG STR:"Line1\nLine2"
                §END_CALL
              §END_BODY
            §END_FUNC[id=f001]
            §END_MODULE[id=m001]
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors);
        Assert.Contains("Console.WriteLine(\"Line1\\nLine2\")", result.GeneratedCode);
    }

    [Fact]
    public void Compile_MismatchedId_ReturnsErrors()
    {
        var source = """
            §MODULE[id=m001][name=Test]
            §END_MODULE[id=m999]
            """;

        var result = Program.Compile(source);

        Assert.True(result.HasErrors);
        Assert.Contains(result.Diagnostics, d => d.Code == "OPAL0101");
    }

    [Fact]
    public void Compile_GeneratesAutoGeneratedHeader()
    {
        var source = """
            §MODULE[id=m001][name=Test]
            §END_MODULE[id=m001]
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors);
        Assert.Contains("<auto-generated>", result.GeneratedCode);
        Assert.Contains("OPAL compiler", result.GeneratedCode);
    }

    [Fact]
    public void Compile_MultipleFunctions_GeneratesAll()
    {
        var source = """
            §MODULE[id=m001][name=Test]
            §FUNC[id=f001][name=Foo][visibility=public]
              §OUT[type=VOID]
              §BODY
              §END_BODY
            §END_FUNC[id=f001]
            §FUNC[id=f002][name=Bar][visibility=private]
              §OUT[type=VOID]
              §BODY
              §END_BODY
            §END_FUNC[id=f002]
            §END_MODULE[id=m001]
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors);
        Assert.Contains("public static void Foo()", result.GeneratedCode);
        Assert.Contains("private static void Bar()", result.GeneratedCode);
    }

    [Fact]
    public void Compile_BoolLiteral_GeneratesCorrectValue()
    {
        var source = """
            §MODULE[id=m001][name=Test]
            §FUNC[id=f001][name=IsEnabled][visibility=public]
              §OUT[type=BOOL]
              §BODY
                §RETURN BOOL:true
              §END_BODY
            §END_FUNC[id=f001]
            §END_MODULE[id=m001]
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors);
        Assert.Contains("return true;", result.GeneratedCode);
    }

    [Fact]
    public void Compile_FloatLiteral_GeneratesCorrectValue()
    {
        var source = """
            §MODULE[id=m001][name=Test]
            §FUNC[id=f001][name=GetPi][visibility=public]
              §OUT[type=FLOAT]
              §BODY
                §RETURN FLOAT:3.14159
              §END_BODY
            §END_FUNC[id=f001]
            §END_MODULE[id=m001]
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors);
        Assert.Contains("return 3.14159;", result.GeneratedCode);
    }

    [Fact]
    public void Compile_InternalVisibility_GeneratesCorrectModifier()
    {
        var source = """
            §MODULE[id=m001][name=Test]
            §FUNC[id=f001][name=Helper][visibility=internal]
              §OUT[type=VOID]
              §BODY
              §END_BODY
            §END_FUNC[id=f001]
            §END_MODULE[id=m001]
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors);
        Assert.Contains("internal static void Helper()", result.GeneratedCode);
    }

    [Fact]
    public void Compile_V2LispExpressions_GeneratesCorrectCode()
    {
        // Test: (== (% i 15) 0) should generate ((i % 15) == 0)
        var source = """
            §M[m001:Test]
            §F[f001:Check:pub]
              §I[i32:i]
              §O[BOOL]
              §BODY
                §RETURN (== (% i 15) 0)
              §END_BODY
            §/F[f001]
            §/M[m001]
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors, string.Join("\n", result.Diagnostics.Select(d => d.Message)));
        Assert.Contains("((i % 15) == 0)", result.GeneratedCode);
    }

    [Fact]
    public void Compile_V2PrintAlias_GeneratesConsoleWriteLine()
    {
        var source = """
            §M[m001:Test]
            §F[f001:Main:pub]
              §O[void]
              §BODY
                §P "Hello v2!"
              §END_BODY
            §/F[f001]
            §/M[m001]
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors, string.Join("\n", result.Diagnostics.Select(d => d.Message)));
        Assert.Contains("Console.WriteLine(\"Hello v2!\")", result.GeneratedCode);
    }

    [Fact]
    public void Compile_V2ImplicitClosing_GeneratesCorrectCall()
    {
        var source = """
            §M[m001:Test]
            §F[f001:Main:pub]
              §O[void]
              §BODY
                §C[Console.WriteLine] "Implicit close"
              §END_BODY
            §/F[f001]
            §/M[m001]
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors, string.Join("\n", result.Diagnostics.Select(d => d.Message)));
        Assert.Contains("Console.WriteLine(\"Implicit close\")", result.GeneratedCode);
    }

    [Fact]
    public void Compile_V2UnaryNot_GeneratesCorrectCode()
    {
        var source = """
            §M[m001:Test]
            §F[f001:Negate:pub]
              §I[BOOL:flag]
              §O[BOOL]
              §BODY
                §RETURN (! flag)
              §END_BODY
            §/F[f001]
            §/M[m001]
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors, string.Join("\n", result.Diagnostics.Select(d => d.Message)));
        Assert.Contains("(!flag)", result.GeneratedCode);
    }

    [Fact]
    public void Compile_V2PrintWithLispExpression_GeneratesCorrectCode()
    {
        var source = """
            §M[m001:Test]
            §F[f001:Main:pub]
              §I[i32:x]
              §O[void]
              §BODY
                §P (+ x 10)
              §END_BODY
            §/F[f001]
            §/M[m001]
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors, string.Join("\n", result.Diagnostics.Select(d => d.Message)));
        Assert.Contains("Console.WriteLine((x + 10))", result.GeneratedCode);
    }

    [Fact]
    public void Compile_V2ChainedOperators_GeneratesCorrectCode()
    {
        // (+ a b c) should generate ((a + b) + c)
        var source = """
            §M[m001:Test]
            §F[f001:Sum3:pub]
              §I[i32:a]
              §I[i32:b]
              §I[i32:c]
              §O[i32]
              §BODY
                §RETURN (+ a b c)
              §END_BODY
            §/F[f001]
            §/M[m001]
            """;

        var result = Program.Compile(source);

        Assert.False(result.HasErrors, string.Join("\n", result.Diagnostics.Select(d => d.Message)));
        // The generated code should chain additions
        Assert.Contains("a + b", result.GeneratedCode);
        Assert.Contains("+ c", result.GeneratedCode);
    }
}
